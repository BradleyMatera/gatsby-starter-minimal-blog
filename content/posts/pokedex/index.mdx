---
title: "Building My Interactive Pokedex: Learning APIs and Web Stuff"
date: "2024-09-01"
tags: ["Projects", "JavaScript", "Tailwind CSS", "APIs", "Learning"]
description: "How I combined the PokeAPI and Pokémon TCG API to create an accessible, responsive Pokédex while learning about data fetching and error handling."
---

## Introduction

I built this interactive Pokédex during a Full Sail University web development course to practise consuming public APIs, managing state on the client, and polishing responsive layouts. The app lets users search for Pokémon, browse the first 151 species, and view trading cards without leaving the page. You can try it at [bradleymatera.github.io/Interactive-Pokedex](https://bradleymatera.github.io/Interactive-Pokedex) and review the code on [GitHub](https://github.com/BradleyMatera/Interactive-Pokedex).

## APIs and Data Sources

| API | Purpose | Notes |
| --- | --- | --- |
| [PokeAPI](https://pokeapi.co/) | Core Pokémon stats, sprites, types | REST API returning JSON, no authentication for low-volume usage. |
| [Pokémon TCG API](https://docs.pokemontcg.io/) | Trading card imagery and metadata | Supports API keys for higher rate limits; includes multiple image sizes. |

Both APIs are free to use, respond quickly, and expose enough nested fields (`types`, `sprites`, `images`) to build a rich interface. I cached responses client-side to avoid re-fetching data when the user revisits a Pokémon.

## Architecture Overview

- **HTML shell:** `index.html` hosts the search form, results container, and quiz modal.  
- **Tailwind CSS:** Utility classes such as `grid grid-cols-1 md:grid-cols-3 gap-4` provide responsive layout without writing custom CSS from scratch.  
- **JavaScript modules:** `main.js` handles Pokémon searches, `cards.js` fetches TCG data, and `quiz.js` powers a small type quiz.  
- **Static hosting:** GitHub Pages serves the site; a GitHub Actions workflow redeploys on every push to main.

```html
<form id="searchForm" class="flex gap-2" aria-label="Search for a Pokémon">
  <label for="searchInput" class="sr-only">Pokémon name</label>
  <input
    id="searchInput"
    type="search"
    name="query"
    placeholder="Search Pokémon…"
    class="p-2 border rounded grow"
    autocomplete="off"
  />
  <button type="submit" class="px-4 py-2 bg-red-500 text-white rounded">
    Search
  </button>
</form>
```

## Fetching and Rendering Pokémon Data

```javascript
async function searchPokemon(query) {
  const endpoint = `https://pokeapi.co/api/v2/pokemon/${encodeURIComponent(query.toLowerCase())}`;
  try {
    const response = await fetch(endpoint);
    if (!response.ok) throw new Error('Not found');
    const data = await response.json();
    renderPokemonCard(data);
  } catch (error) {
    renderError(`${query} isn’t available. Try another name or browse the full list.`);
  }
}
```

The `renderPokemonCard` helper prints the sprite, types, base stats, and abilities, while Tailwind provides consistent spacing. Each image includes descriptive alternative text so screen readers announce the content correctly.

### Handling Lists and Rate Limits

- **Initial list:** On load the app fetches `https://pokeapi.co/api/v2/pokemon?limit=151`, then batches follow-up requests to avoid hammering the API.  
- **Caching:** A `Map` stores results keyed by Pokémon name, so repeat searches render instantly without a new network call.  
- **TCG imagery:** The card view checks for `card.images.small` before rendering; missing images are skipped to avoid broken thumbnails.

### Error Handling and Accessibility

- Invalid queries display a friendly message instead of crashing the UI.  
- Network failures trigger a toast notification and retain the last valid results.  
- Results containers use `aria-live="polite"` so screen readers announce updates.  
- Focus returns to the search input after each search, supporting keyboard and assistive users.

## Lessons Learned

1. **APIs require defensive coding.** Even reliable services return errors or missing fields, so every fetch is wrapped with checks and fallbacks.  
2. **Batching requests improves performance.** Fetching all Gen I Pokémon sequentially slowed the browser; batching ten at a time kept the interface responsive.  
3. **Utility CSS accelerates iteration.** Tailwind let me focus on accessibility and data presentation instead of hand-coding styles.  
4. **Accessibility should ship from day one.** Labels, live regions, and keyboard support were easier to add early than retrofit later.

## Next Steps

- Add filters for type, generation, and region backed by cached data.  
- Persist the most recent search results in local storage so offline users can resume quickly.  
- Integrate automated accessibility and performance checks in CI (axe, Lighthouse).  
- Explore server-side rendering to support environments where client-side JavaScript is disabled.

## External Resources

- PokeAPI Documentation, “Pokémon Endpoint,” https://pokeapi.co/docs/v2.  
- Pokémon TCG Developers, “API Reference,” https://docs.pokemontcg.io/.
