---
title: "Interactive Pokedex: Static Build With Search"
date: "2025-05-01"
slug: "/interactive-pokedex"
tags: ["nextjs", "api", "frontend"]
description: "A minimal static Pokedex build with search and clear verification steps."
theme: "Front-End"
---

This is a static Pokedex demo with client side search.

It uses build time data and a simple search filter.

You will fetch data, render cards, and verify search works.

I cannot verify these steps from this blog repo. Treat this as a lab guide you can run locally.

## The promise

By the end, you will:

- build a static list from a public API
- add a simple search filter
- verify the output with clear checks

> "If the list renders and search filters, the demo works."

## What this is

**High level:** A static Pokedex is a list of Pokemon that is built ahead of time.

**Low level:** You fetch data during build, render a list, and filter it in the browser.

**Key terms:**

- **Static build:** HTML generated at build time.
- **Client side search:** Filtering done in the browser after load.

## What you need

- Node 18+
- Next.js
- PokÃ©API

## Start to Finish

### Step 1: Create the Next.js app
Goal:
Scaffold a new Next.js project.

Actions:
- Command:
  ```bash
  npx create-next-app@latest pokedex-demo
  cd pokedex-demo
  ```

Why:
Next.js gives you a static build option. It also includes routing by default. This keeps the demo simple. You can deploy the static output to GitHub Pages later.

Verify:
- Run:
  ```bash
  npm run dev
  ```
- Expected: the starter page loads.
- This confirms the project runs.

If it fails:
- Symptom: dev server fails to start.  
  **Fix:** reinstall dependencies and retry.

### Step 2: Fetch Pokemon at build time
Goal:
Load a list of Pokemon for static rendering.

Actions:
- File path: `app/page.tsx` or `pages/index.tsx`
- Add a fetch call:
  ```ts
  const res = await fetch("https://pokeapi.co/api/v2/pokemon?limit=151");
  const data = await res.json();
  ```
- Render the list of names.

Why:
Build time fetch makes the page static. It also avoids a server at runtime. This keeps the demo fast and simple. You can verify the list output easily.

Verify:
- Run:
  ```bash
  npm run dev
  ```
- Expected: a list of names appears.
- This confirms the fetch and render work.

If it fails:
- Symptom: fetch error.  
  **Fix:** check the API URL and network.

### Step 3: Add search filtering
Goal:
Filter the list by input.

Actions:
- Add a state value for the query.
- Filter the list before rendering:
  ```ts
  const filtered = items.filter((p) => p.name.includes(query.toLowerCase()));
  ```

Why:
Search is the main interactive feature. Filtering in the browser is fast for small lists. This keeps the demo offline friendly. It also makes the UI more useful.

Verify:
- Type a name into the search input.
- Expected: the list filters immediately.
- This confirms search works.

If it fails:
- Symptom: no filtering.  
  **Fix:** ensure the query value updates on input.

## Verify it worked

- The list renders.
- Search filters results.
- The page loads without errors.

## Common mistakes

- **Symptom:** API fetch fails at build time.  
  **Cause:** missing network access.  
  **Fix:** run the build with internet access or cache results.

- **Symptom:** Search is case sensitive.  
  **Cause:** no normalization.  
  **Fix:** use `toLowerCase()` on both sides.

- **Symptom:** Build fails on fetch.  
  **Cause:** incorrect fetch usage in the app router.  
  **Fix:** move fetch to a server component.

## Cheat sheet

- Fetch 151 Pokemon.
- Render the list.
- Filter by query.

## Next steps

- Add detail pages.
- Add type filters.

## Related links

- https://pokeapi.co/
- https://nextjs.org/docs

## Final CTA

Keep the demo small and verify the core behavior first.
