---
title: "Learning Zig Basics with an OBJ Parser"
date: "2024-07-01"
tags: ["Projects", "Zig", "3D Parsing", "JavaScript", "PixiJS"]
description: "How I used Zig to parse Wavefront OBJ files, what manual memory management taught me, and how the data feeds into a PixiJS visualisation."
---

## Introduction

My goal with this project was to move beyond garbage-collected languages and experience manual memory management first-hand. Zig appealed because it emphasises explicit allocation, predictable control flow, and low-level ergonomics without macros or hidden runtimes [1]. Parsing Wavefront OBJ files felt like a practical way to learn: the format is text-based, well documented, and directly connected to 3D rendering workflows.

## Project Structure

```
obj-parser/
├── src/
│   ├── main.zig
│   └── parser.zig
├── examples/
│   ├── cube.obj
│   └── cube.mtl
└── web/
    └── preview.js
```

- `main.zig` handles command-line invocation.  
- `parser.zig` exposes `parseOBJ`, returning vertices and faces.  
- `web/preview.js` uses PixiJS to visualise vertices once exported.

## Reading Files in Zig

The entry point allocates a buffer, reads the OBJ file, and passes the contents to the parser:

```zig
const std = @import("std");

pub fn main() !void {
    const allocator = std.heap.page_allocator;
    const file = try std.fs.cwd().openFile("examples/cube.obj", .{});
    defer file.close();

    const contents = try file.readToEndAlloc(allocator, 1024 * 1024);
    defer allocator.free(contents);

    const vertices = try parser.parseOBJ(contents, allocator);
    defer allocator.free(vertices);

    std.debug.print("Loaded {d} vertices\n", .{vertices.len});
}
```

`try` propagates errors up the call stack, and `defer` ensures the buffer is freed—habits that prevent leaks in Zig’s explicit memory model.

## Parsing Vertices and Faces

`parseOBJ` scans each line, detects prefixes, and builds typed arrays:

```zig
pub const Vertex = struct { x: f32, y: f32, z: f32 };

pub fn parseOBJ(content: []const u8, allocator: std.mem.Allocator) ![]Vertex {
    var vertices = std.ArrayList(Vertex).init(allocator);
    defer vertices.deinit();

    var lines = std.mem.split(u8, content, "\n");
    while (lines.next()) |line| {
        if (line.len == 0) continue;
        if (std.mem.startsWith(u8, line, "v ")) {
            var parts = std.mem.split(u8, line[2..], " ");
            const x = try std.fmt.parseFloat(f32, parts.next() orelse return error.InvalidVertex);
            const y = try std.fmt.parseFloat(f32, parts.next() orelse return error.InvalidVertex);
            const z = try std.fmt.parseFloat(f32, parts.next() orelse return error.InvalidVertex);
            try vertices.append(Vertex{ .x = x, .y = y, .z = z });
        }
        // Faces handled similarly with indices and optional normals/UVs.
    }

    return vertices.toOwnedSlice();
}
```

The compiler forcefully reminds you to handle every branch—missing floats or malformed lines trigger `error.InvalidVertex`, which I test in the unit suite.

## Connecting to PixiJS

Once the parser returns data, a simple bridge writes JSON for the browser. PixiJS then renders 2D projections to validate the geometry:

```javascript
import * as PIXI from 'pixi.js';

fetch('cube.json')
  .then((response) => response.json())
  .then(({ vertices }) => {
    const app = new PIXI.Application({ width: 800, height: 600, background: '#111' });
    document.body.appendChild(app.view);

    const graphics = new PIXI.Graphics();
    graphics.beginFill(0xffffff);
    vertices.forEach(({ x, y }) => graphics.drawCircle(400 + x * 100, 300 - y * 100, 2));
    graphics.endFill();

    app.stage.addChild(graphics);
  });
```

The visualisation helped validate scaling math and uncovered coordinate issues quickly.

## Lessons Learned

1. **Manual memory management clarifies ownership.** Allocators and `defer` statements forced me to plan lifecycle up front. The Zig documentation emphasises that the language does not automatically free heap allocations; forgetting to call `deinit` emerges as a leak [1].  
2. **Wavefront OBJ is straightforward but strict.** Parsing vertices and faces required guarding against empty tokens and 1-indexed references.  
3. **Testing is non-negotiable.** Unit tests covering blank lines, invalid coordinates, and missing faces saved hours of debugging.  
4. **Interoperability is powerful.** Combining Zig for parsing and PixiJS for rendering gave me the best of both ecosystems: performance on the backend and rapid visual feedback on the frontend.

## Next Steps

- Support normals and texture coordinates, not just position data.  
- Export binary formats for faster loading in JavaScript.  
- Integrate with a WebGPU renderer to eliminate the JSON bridge.  
- Package the parser as a Zig module with documentation so others can extend it.

## References

[1] Zig Language Documentation, “Overview,” https://ziglang.org/documentation/master/.  
[2] Wavefront OBJ File Format Specification, https://people.sc.fsu.edu/~jburkardt/data/obj/obj.html.
