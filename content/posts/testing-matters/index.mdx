---
title: "Why Testing Matters: From Jest to Integration Tests"
date: "2025-09-29"
slug: "/why-testing-matters"
tags: ["Testing", "Quality", "DevOps"]
description: "How I layer unit, integration, and end-to-end tests across front-end and back-end projects to ship changes with confidence."
theme: "Front-End & Full-Stack"
---

> **Context:** Student-level test strategy I use on my own repos and internship labs; I haven’t owned QA for a production org yet.  
> **AI assist:** ChatGPT helped outline the pyramid; I filled it with tools I actually touch (and labeled which ones are still labs).  
> **Status:** Honest view of what’s automated today vs. what’s aspirational (contract testing is still in pilot).

## TL;DR

- **Layered suites keep risk low.** Unit, component, integration, contract, and E2E tests provide coverage where it counts without burning velocity.[^jest]
- **Production-like tooling matters.** MSW, LocalStack, Playwright, and Percy mirror real infrastructure so regressions surface early.[^rtl]
- **Automation guards every merge.** Git hooks, CI pipelines, and nightly contract checks keep quality gates consistent across teams.
- **Maintenance beats flaky retries.** Deterministic fixtures, isolated databases, and monthly pruning preserve trust in the suite.

## Testing Goals

- Catch regressions at the smallest scope possible while validating real user paths.
- Give developers rapid, actionable feedback during local development and CI runs.
- Align automated checks with acceptance criteria crafted alongside designers and PMs.
- Keep suites resilient so they scale with the codebase instead of becoming a bottleneck.

## Testing Pyramid in Practice

| Layer | What it covers | Tools | Cadence |
| --- | --- | --- | --- |
| Unit tests | Pure functions, utilities, React hooks | Jest, Vitest | Watch mode on every save. |
| Component tests | UI behaviour in isolation | React Testing Library, Storybook test runner | CI + pre-merge on UI changes. |
| Integration tests | API endpoints, database interactions | Supertest, Prisma test DB, LocalStack | Every pull request (personal projects). |
| Contract tests | API request/response contracts | Pact, OpenAPI schema validation | Pilot stage—run manually before bigger refactors. |
| End-to-end tests | Full user flows | Playwright, Cypress | Scheduled runs + pre-deploy smoke suites for Netlify deploys.

Unit tests stay fast while end-to-end tests mimic production flows. Balancing both prevents brittle suites and ensures real issues get caught.

## Unit & Component Tests

- **Utility functions.** Projects like CheeseMath use Jest snapshots and property-based testing to cover negative inputs and floating-point quirks.[^jest]  
- **React components.** React Testing Library asserts against accessible roles (`getByRole`, `getByLabelText`) so tests match user interactions.[^rtl]  
- **Mock strategy.** MSW intercepts network calls, guaranteeing consistent loading, success, and error coverage without brittle mocks.

## Integration Tests

- **API validation.** Supertest spins up Express apps in memory, hitting routes with realistic payloads while seeding a disposable PostgreSQL DB (Docker).  
- **AWS services.** LocalStack emulates S3, DynamoDB, and SNS to confirm infrastructure wiring without incurring cloud costs.  
- **Data migrations.** Suites run migrations against throwaway databases to catch schema drift before production deploys.

## End-to-End Coverage

- **Playwright flows.** Scripts cover auth, CRUD, and accessibility spot checks (focus order, keyboard navigation).  
- **Visual diffs.** Percy snapshots are in pilot mode for this Gatsby site to catch unexpected UI shifts.  
- **Performance budgets.** Lighthouse CI enforces LCP/CLS thresholds inside GitHub Actions to prevent regressions.

## Keeping Tests Fast & Reliable

- **Parallelisation.** Per-worker databases (`test_db_${process.pid}`) avoid cross-test contamination.  
- **Deterministic data.** Factories generate predictable fixtures, reducing flaky assertions.  
- **Targeted retries.** Only E2E suites get limited retries to smooth over transient network blips.  
- **Continuous pruning.** Monthly audits remove redundant tests and flag noisy assertions.

## Automation Pipeline

1. Pre-commit hooks run lint and unit tests.  
2. Pull requests trigger unit, component, and integration suites in CI.  
3. Merges to main kick off end-to-end smoke tests and deploy previews.  
4. Nightly jobs (or manual runs when I’m iterating quickly) execute contract tests against staging to catch breaking API changes.

## Results

- **Fewer regressions in side projects.** Automated gates catch most issues before I publish updates to Netlify/GitHub Pages, so hotfixes are rare.  
- **Faster feedback loops.** Watch-mode unit tests and Playwright smoke suites surface issues minutes after code changes.  
- **Better collaboration.** Even on student teams, sharing acceptance criteria + early contract tests keeps frontend and backend iterations aligned.

## Lessons Learned

- Tests double as documentation when written from the user’s perspective.  
- Small, focused tests outlive sprawling “god tests” and are easier to refactor.  
- Building coverage alongside features is cheaper than retrofitting it later.  
- Including designers and PMs in acceptance reviews ensures suites reflect real user needs.

## Next Steps

- Expand contract coverage to event-driven systems (SNS/SQS payloads and schemas).
- Integrate automated axe-core accessibility checks into component pipelines.
- Pilot Playwright Component Testing to bridge the gap between story-level and browser-level coverage.

## Key Takeaways

- **Layered suites catch regressions early without sacrificing speed.**
- **Production-like test harnesses keep results trustworthy.**
- **Routine maintenance turns testing from overhead into a force multiplier.**

## References

[^jest]: Jest Documentation, “Getting Started,” accessed May 2025, https://jestjs.io/docs/getting-started.  
[^rtl]: Testing Library, “Guiding Principles,” accessed May 2025, https://testing-library.com/docs/guiding-principles.
