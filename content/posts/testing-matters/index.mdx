---
title: "Testing That I Actually Run: A Small Pyramid"
date: "2025-09-29"
slug: "/why-testing-matters"
tags: ["testing", "quality", "devops"]
description: "A small, honest testing stack with exact commands, checks, and gaps."
theme: "Front-End & Full-Stack"
---

I test to catch real bugs, not to impress anyone.

This post shows a tiny testing pyramid that I actually run on demos.

You will set up a single test command, run it, and document the gaps.

I cannot verify these steps from this blog repo. Treat this as a lab guide you can run locally.

## The promise

By the end, you will:

- run a single test command
- add one focused unit test
- document one testing gap you will fix later

> "A small test suite that runs beats a big suite that does not."

## What this is

**High level:** A testing pyramid keeps most tests small and fast, then adds fewer higher-level checks.

**Low level:** You wire one test runner, add one unit test, then perform one manual smoke check.

**Key terms:**

- **Unit test:** A test for a single function.
- **Component test:** A test for a UI component.
- **Smoke check:** A quick manual run of core flows.

## What you need

- Node 18+
- A repo with a `package.json`
- A test runner like Vitest or Jest

## Start to Finish

### Step 1: Add a test script
Goal:
Ensure the repo has a single command for tests.

Actions:
- File path: `package.json`
- Add or confirm:
  ```json
  {
    "scripts": {
      "test": "vitest run"
    }
  }
  ```
- Command:
  ```bash
  npm install -D vitest
  ```

Why:
A single command is how you avoid broken test instructions. It also makes CI possible later. Without a consistent script, tests become tribal knowledge. This step makes your test entry point explicit.

Verify:
- Run:
  ```bash
  npm test
  ```
- Expected: Vitest runs and exits without crashing.
- This confirms the test runner works.

If it fails:
- Symptom: `vitest: command not found`.
- Fix: install Vitest and re-run `npm test`.

### Step 2: Add one unit test
Goal:
Add a small unit test that proves the runner works.

Actions:
- File path: `src/sum.ts`
- Add:
  ```ts
  export function sum(a: number, b: number) {
    return a + b;
  }
  ```
- File path: `src/sum.test.ts`
- Add:
  ```ts
  import { sum } from "./sum";
  import { describe, it, expect } from "vitest";

  describe("sum", () => {
    it("adds two numbers", () => {
      expect(sum(2, 3)).toBe(5);
    });
  });
  ```

Why:
A tiny test proves the entire testing loop. It also shows the exact pattern you can repeat later. This avoids complex setup and keeps the first pass fast. One passing test is more valuable than ten unrun tests.

Verify:
- Run:
  ```bash
  npm test
  ```
- Expected: one passing test called "adds two numbers".
- This confirms the test file is detected and executed.

If it fails:
- Symptom: test file not found.
- Fix: ensure the file name ends with `.test.ts`.

### Step 3: Record one smoke check
Goal:
Document the one manual flow you check every time.

Actions:
- File path: `docs/testing-notes.md`
- Add:
  ```text
  Smoke check:
  - Load the home page
  - Click the primary CTA
  - Confirm the page navigates
  ```

Why:
Manual checks are still valid, but they need to be written down. This keeps the check repeatable. It also tells future you what was actually verified. A simple file is enough.

Verify:
- Open the app locally and follow the bullets.
- Expected: each step works without errors.
- This confirms your smoke check is real.

If it fails:
- Symptom: you forgot the steps.
- Fix: update the list to reflect what you actually tested.

## Verify it worked

- `npm test` runs without crashing.
- At least one test passes.
- The smoke check steps are documented.

## Common mistakes

- **Symptom:** Tests never run.  
  **Cause:** No test script defined.  
  **Fix:** Add the `test` script and run it once.

- **Symptom:** Tests pass locally but fail for others.  
  **Cause:** Missing dev dependency.  
  **Fix:** Add the test runner to `devDependencies`.

- **Symptom:** Smoke checks are vague.  
  **Cause:** No written steps.  
  **Fix:** Write down exact clicks and expected outcomes.

## Cheat sheet

- One `npm test` command.
- One unit test.
- One smoke check note.
- Document gaps honestly.

## Next steps

- Add a second unit test for the most fragile function.
- Add a basic component test if you use React.
- If you want CI, add it later and link the workflow file.

## Related links

- https://vitest.dev/
- https://testing-library.com/docs/

## Final CTA

Run your tests once today and document one gap. That is enough to move forward.
