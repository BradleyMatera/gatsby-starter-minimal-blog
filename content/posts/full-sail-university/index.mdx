---
title: "What Formal Training Actually Gave Me"
date: "2025-01-15"
slug: "/full-sail-university-web-development"
tags: ["education", "process", "career"]
description: "A clear breakdown of what I kept from formal training and how I use it now."
theme: "Career"
---

Formal training did not turn me into an engineer by itself. What it did give me was repeated exposure to building, breaking, fixing, and presenting software projects under time constraints. That only matters if those behaviors still show up in how I work today. This post is a straight explanation of what actually came out of my Web Development degree and how it connects to the work I do now.

There is no system to install here and no artificial workflow. This is simply a record of what was real in that program and what carried forward.

## What the program actually looked like

![Developer writing code](https://media.giphy.com/media/qgQUggAC3Pfv687qPC/giphy.gif)

The Web Development program at Full Sail runs on short monthly courses. Each month you switch topics, deliver a project, present it, then move on. That pace forces you to ship something even when you do not feel ready. You do not sit in theory for long. You build, submit, and iterate.

The curriculum covered HTML, CSS, JavaScript, React, basic backend concepts, databases, UX, project planning, and cloud fundamentals. None of these were mastered in isolation. The value came from repeatedly being dropped into unfamiliar stacks and being required to produce a working deliverable anyway.

## The behavior it produced

![Debugging in action](https://media.giphy.com/media/3og0IPxMM0erATueVW/giphy.gif)

The useful outcome of that environment was not memorizing syntax. It was learning how to:

• Start from a blank folder and get something running
• Read documentation fast enough to unblock yourself
• Debug when instructions are incomplete or wrong
• Present work that is not perfect but functional
• Take feedback and apply it to the next build

Those behaviors are the same ones I use now when building personal projects, working inside existing codebases, or learning new cloud services. That is the real connection.

## Where it shows up today

![Deploying to cloud](https://media.giphy.com/media/5xaOcLGvzHxDKjufnLW/giphy.gif)

After graduation, those same behaviors show up in three places:

First, in personal projects. I routinely spin up new repos, assemble stacks, deploy them, break them, and fix them. That loop came directly from being forced to deliver monthly projects on deadlines.

Second, in my AWS internship. The guided labs and capstone work required jumping into unfamiliar services, reading service docs, wiring components together, debugging failures, and producing working deployments. That felt like an accelerated version of school projects, just inside real AWS environments instead of classroom ones.

Third, in open source contributions. Running an unfamiliar project locally, fixing onboarding friction, improving documentation, submitting PRs, and tracking issues is the same pattern: enter a codebase, understand it, make a small improvement, leave a record.

## What did not carry forward

Not everything from school remained useful. Some class projects no longer run. Some frameworks taught are outdated. Some assignments were done only to meet grading criteria. That is normal. The output that matters is what still builds, deploys, or taught a repeatable behavior. Everything else is just history.

## Closing

The degree did not magically create engineering skill. It created a high-frequency environment for shipping imperfect software, learning under pressure, and adapting quickly. Those behaviors are still present in how I work now. That is the only part of formal training that matters in practice.
