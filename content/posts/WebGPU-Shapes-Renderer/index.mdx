---
title: "Messing with WebGPU Shapes Renderer: Learning a New Library"
date: "2024-06-01"
tags: ["Projects", "WebGPU", "JavaScript", "Tailwind CSS", "Learning"]
description: "What I learned by forking the leaf-js WebGPU renderer, building a UI around it, and inspecting the pipeline, shaders, and accessibility implications."
---

## Introduction

To understand WebGPU I forked [deondreE/leaf-js](https://github.com/deondreE/leaf-js), a demo that renders geometric shapes using WebGPU and WGSL shaders. Rather than rewriting the renderer, I built a front-end around it, instrumented the code, and observed how pipeline configuration, shader math, and accessibility concerns interact. The result lives at [bradleymatera.github.io/leaf-js](https://bradleymatera.github.io/leaf-js/) and helped me transition from “I’ve never touched WebGPU” to having a practical grasp of its core ideas.

## Why WebGPU?

WEBGPU is the next-generation graphics and compute API for the web, designed to deliver lower CPU overhead and better access to modern GPU features than WebGL [1]. It executes shaders written in WGSL, uses GPU command buffers, and exposes pipeline configuration similar to Vulkan or Direct3D. Forking an existing project let me focus on learning the API surface without building the entire rendering stack from scratch.

## Front-End Enhancements

The original project required editing `main.ts` to switch shapes. I wanted a UI that let classmates explore the renderer without touching code, so I built a Tailwind-powered control panel:

```html
<select id="shape-selector" class="p-2 border rounded bg-gray-100" aria-label="Select a shape to render">
  <option value="triangle">Triangle</option>
  <option value="square">Square</option>
  <option value="pentagon">Pentagon</option>
  <option value="diamond">Diamond</option>
  <option value="hexagon">Hexagon</option>
</select>
<canvas id="canvas" class="w-full h-96 border rounded"></canvas>
```

The dropdown maps to the renderer’s initialisation functions:

```ts
const shapes = {
  triangle: initTriangle,
  square: initSquare,
  pentagon: initPentagon,
  diamond: initDiamond,
  hexagon: initHexagon,
};

selector.addEventListener('change', async (event) => {
  const adapter = await navigator.gpu.requestAdapter();
  if (!adapter) {
    renderError('WebGPU not supported in this browser.');
    return;
  }
  const device = await adapter.requestDevice();
  const context = canvas.getContext('webgpu');
  shapes[event.target.value]?.({ device, context });
});
```

Tailwind utilities (`grid`, `p-2`, `md:w-1/2`, etc.) handle responsive layout, and ARIA labels ensure assistive technologies announce control changes.

## Inspecting the Pipeline

The renderer constructs a pipeline via `device.createRenderPipeline`. By toggling `primitive.topology` between `triangle-list` and `line-list` I observed the difference between filled shapes and wireframes. Examining the vertex shader showed how WGSL positions vertices inside clip space:

```wgsl
@vertex
fn main(@builtin(vertex_index) vertexIndex: u32) -> @builtin(position) vec4<f32> {
  var positions = array<vec2<f32>, 3>(
    vec2(0.0, 0.5),
    vec2(-0.5, -0.5),
    vec2(0.5, -0.5),
  );
  return vec4<f32>(positions[vertexIndex], 0.0, 1.0);
}
```

When I exaggerated the coordinates (for example, `vec2(2.0, 0.5)`) the triangle disappeared because clip space spans `[-1, 1]` in each axis—an instant way to internalise WebGPU’s coordinate system.

## Debugging a Diamond

Selecting the diamond shape produced a distorted quadrilateral. Logging the vertex array revealed uneven spacing:

```wgsl
var positions = array<vec2<f32>, 4>(
  vec2(0.0, 0.5),
  vec2(-0.5, 0.0),
  vec2(0.0, -0.5),
  vec2(0.5, 0.0),
);
```

The legibility issue came from the fragment shader’s solid colour plus the pipeline’s triangle strip configuration. Instead of rewriting core logic, I documented the observation for potential upstream fixes and focused on UI polish and instrumentation.

## Accessibility and Deployment

- Added keyboard focus states and `aria-live` announcements when new shapes render.  
- Ensured the control panel remains usable on mobile with `min-w-full` and `touch-action: manipulation`.  
- Deployed to GitHub Pages via a GitHub Actions workflow; I plan to add automated accessibility checks (axe, Lighthouse) in a future iteration.

## Lessons Learned

1. **WebGPU pipelines are explicit.** You choose shader modules, topology, colour formats, and buffers—there’s no implicit default. That reinforces the importance of reading the spec and inspecting each configuration.  
2. **WGSL mirrors GPU values.** Understanding the clip space range and how vertex indices map into arrays makes debugging geometry straightforward.  
3. **Documentation is gold.** The MDN WebGPU overview and the official specification bridged the gap between theoretical knowledge and practical debugging.  
4. **Accessibility still applies to graphics demos.** Keyboard navigation, descriptive labels, and responsive design matter even in experimental projects.

## Next Steps

- Fix the diamond distortion by rewriting the vertex shader to normalise coordinates.  
- Implement shape animations using time-uniforms to better understand buffer updates.  
- Add light/dark themes and publish the accessibility audit results.  
- Experiment with WebGPU compute shaders to expand beyond static geometry.

## References

[1] MDN Web Docs, “WebGPU API,” https://developer.mozilla.org/en-US/docs/Web/API/WebGPU_API.  
[2] W3C GPU for the Web Community Group, “WebGPU Specification,” https://gpuweb.github.io/gpuweb/.
