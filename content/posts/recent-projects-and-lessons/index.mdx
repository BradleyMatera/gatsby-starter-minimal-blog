---
title: "Exploring My Recent Project: BasicServerSetup"
date: "2024-12-04"
slug: "/recent-project-basicserversetup"
tags: ["Projects", "APIs", "Backend"]
banner: ./background.jpg
description: "How I built a time-tracking app with Node.js and Express, the API endpoints it exposes, and what I learned about separation of concerns and early testing."
---

> **Context:** BasicServerSetup is a solo practice project (in-memory store, Heroku hobby dyno) I use to learn REST patterns—no paying customers rely on it.  
> **AI assist:** ChatGPT + Copilot drafted some controller/README text; I edited it before publishing this case study.  
> **Status:** Honest overview of what works today and what’s still TODO (JWT auth, persistent DB, automated tests).

## TL;DR

- **Lightweight time-tracking API with real separation.** Node.js + Express handles auth, clock events, and timesheet retrieval while a static Tailwind UI consumes the endpoints.
- **Independent deploys reduce friction.** Heroku hosts the API, GitHub Pages hosts the client, letting me ship UI tweaks without touching backend builds.
- **Testing and docs came first.** Postman suites and concise READMEs surfaced edge cases and made peer reviews faster.
- **Ready for persistence upgrades.** Controllers stay thin so swapping the in-memory store for MongoDB or Postgres is low-risk.

## Project Goals

- Practice designing a REST API that cleanly separates controllers, models, and middleware.
- Build a static dashboard that interacts with the API using accessible feedback patterns.
- Deploy backend and frontend independently to mirror production pipelines on a smaller scale.
- Capture lessons about documentation, testing, and deployment hygiene along the way.

## Implementation Highlights

### Architecture snapshot

| Layer | Technology | Notes |
| --- | --- | --- |
| API | Node.js, Express | Authentication, clock-in/out logic, timesheet retrieval. |
| Frontend | Static HTML + Tailwind CSS | Simple dashboard that consumes the API via Fetch. |
| Deployment | Heroku (API), GitHub Pages (frontend) | Enables independent scaling and easy demos. |

```
BasicServerSetup/
├── app/
│   ├── controllers/
│   │   ├── timeController.js
│   │   └── userController.js
│   ├── models/
│   │   ├── timeEntryModel.js
│   │   └── userModel.js
│   ├── routes/index.js
│   └── utils/authMiddleware.js
└── frontend/index.html
```

`authMiddleware.js` injects authentication guard rails, keeping controllers focused on business logic.

### Core endpoints stay focused

| Route | Payload | Description |
| --- | --- | --- |
| `POST /register` | `{ username, password }` | Creates a user (stored in memory). |
| `POST /login` | `{ username, password }` | Issues a session token (placeholder). |
| `POST /clockin` | Header `x-user-id` | Records a start timestamp. |
| `POST /clockout` | Header `x-user-id` | Records an end timestamp and computes duration. |
| `GET /timesheet` | Header `x-user-id` | Returns all entries for the user. |

These endpoints are intentionally simple so I can swap the data store later (MongoDB or Postgres) without rewriting controllers.

### Frontend workflow keeps feedback tight

The static client calls the API with `fetch`, handles errors, and renders a timesheet table. Tailwind provides rapid styling:

```javascript
async function clockIn() {
  const response = await fetch(`${API_BASE}/clockin`, {
    method: 'POST',
    headers: { 'x-user-id': currentUserId },
  });
  if (!response.ok) {
    showToast('Unable to clock in. Please try again.');
  }
}
```

Error states are surfaced with lightweight toasts, ensuring the UI communicates network or validation issues clearly.

### Deployment strategy mirrors production workflows

- **Backend (Heroku):** Deployed via GitHub integration with environment variables stored in Heroku’s Config Vars.  
- **Frontend (GitHub Pages):** Hosted separately, pointing API requests to Heroku’s domain.  
- **CORS:** Enabled on the Express server so the static site can communicate with the API.

This split clarified how to iterate on the backend without redeploying the UI, and vice versa.

## Results

- **Controllers stayed database agnostic.** Keeping logic in models means moving to MongoDB or PostgreSQL requires minimal rewiring.
- **Independent deploys sped up iteration.** Shipping UI copy updates or styling never blocked on API redeploys.
- **Documentation shortened reviews.** Teammates could clone the repo and hit Postman collections without hand-holding.

## Lessons Learned

1. **Separation of concerns matters.** Keeping controllers, models, and middleware distinct simplified debugging and future enhancements.  
2. **Early endpoint testing pays dividends.** Postman tests surfaced authentication edge cases before I wrote the UI.  
3. **Documentation accelerates reuse.** Maintaining a concise README and API reference made handoffs easier when classmates reviewed the project.  
4. **Deployment hygiene is worth the effort.** Even a small project benefits from environment variables, health checks, and structured logs.

## Next Steps

- Replace the in-memory store with MongoDB (via Mongoose) or PostgreSQL.  
- Introduce JWT-based authentication for stateless sessions.  
- Build a React or Next.js front end for richer interactions.  
- Add unit and integration tests using Jest and Supertest.  
- Instrument the API with request metrics and structured logging.

## Key Takeaways

- **Thin controllers make future database swaps painless.**
- **Independent frontend/backend deploys mimic real-world pipelines.**
- **Investing in docs and tests early keeps feedback cycles short.**

## Repository

https://github.com/BradleyMatera/BasicServerSetup
