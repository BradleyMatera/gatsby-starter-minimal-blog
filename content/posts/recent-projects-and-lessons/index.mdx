---
title: "Exploring My Recent Project: BasicServerSetup"
date: "2024-12-04"
slug: "/recent-project-basicserversetup"
tags: ["Projects", "APIs", "Backend"]
banner: ./background.jpg
description: "How I built a time-tracking app with Node.js and Express, the API endpoints it exposes, and what I learned about separation of concerns and early testing."
---

## Introduction

BasicServerSetup is a lightweight time-tracking system I assembled to practise designing REST APIs, wiring a static front end to a Node.js backend, and deploying both pieces independently. The application allows users to register, authenticate, clock in/out, and review their timesheet entries. While the data layer currently lives in memory, the architecture mirrors how I would structure a production-grade service.

## Architecture at a Glance

| Layer | Technology | Notes |
| --- | --- | --- |
| API | Node.js, Express | Authentication, clock-in/out logic, timesheet retrieval. |
| Frontend | Static HTML + Tailwind CSS | Simple dashboard that consumes the API via Fetch. |
| Deployment | Heroku (API), GitHub Pages (frontend) | Enables independent scaling and easy demos. |

```
BasicServerSetup/
├── app/
│   ├── controllers/
│   │   ├── timeController.js
│   │   └── userController.js
│   ├── models/
│   │   ├── timeEntryModel.js
│   │   └── userModel.js
│   ├── routes/index.js
│   └── utils/authMiddleware.js
└── frontend/index.html
```

`authMiddleware.js` injects authentication guard rails, keeping controllers focused on business logic.

## Key Endpoints

| Route | Payload | Description |
| --- | --- | --- |
| `POST /register` | `{ username, password }` | Creates a user (stored in memory). |
| `POST /login` | `{ username, password }` | Issues a session token (placeholder). |
| `POST /clockin` | Header `x-user-id` | Records a start timestamp. |
| `POST /clockout` | Header `x-user-id` | Records an end timestamp and computes duration. |
| `GET /timesheet` | Header `x-user-id` | Returns all entries for the user. |

These endpoints are intentionally simple so I can swap the data store later (MongoDB or Postgres) without rewriting controllers.

## Frontend Workflow

The static client calls the API with `fetch`, handles errors, and renders a timesheet table. Tailwind provides rapid styling:

```javascript
async function clockIn() {
  const response = await fetch(`${API_BASE}/clockin`, {
    method: 'POST',
    headers: { 'x-user-id': currentUserId },
  });
  if (!response.ok) {
    showToast('Unable to clock in. Please try again.');
  }
}
```

Error states are surfaced with lightweight toasts, ensuring the UI communicates network or validation issues clearly.

## Deployment Strategy

- **Backend (Heroku):** Deployed via GitHub integration with environment variables stored in Heroku’s Config Vars.  
- **Frontend (GitHub Pages):** Hosted separately, pointing API requests to Heroku’s domain.  
- **CORS:** Enabled on the Express server so the static site can communicate with the API.

This split clarified how to iterate on the backend without redeploying the UI, and vice versa.

## Lessons Learned

1. **Separation of concerns matters.** Keeping controllers, models, and middleware distinct simplified debugging and future enhancements.  
2. **Early endpoint testing pays dividends.** Postman tests surfaced authentication edge cases before I wrote the UI.  
3. **Documentation accelerates reuse.** Maintaining a concise README and API reference made handoffs easier when classmates reviewed the project.  
4. **Deployment hygiene is worth the effort.** Even a small project benefits from environment variables, health checks, and structured logs.

## Possible Next Steps

- Replace the in-memory store with MongoDB (via Mongoose) or PostgreSQL.  
- Introduce JWT-based authentication for stateless sessions.  
- Build a React or Next.js front end for richer interactions.  
- Add unit and integration tests using Jest and Supertest.  
- Instrument the API with request metrics and structured logging.

## Repository

https://github.com/BradleyMatera/BasicServerSetup
