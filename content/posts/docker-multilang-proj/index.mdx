---
title: "Containerizing Multi-Language Projects with Docker: A Practical Guide"
date: "2024-07-15"
tags: ["Docker", "Node.js", "Python", "DevOps", "Containerization"]
description: "Learn how to use Docker and Compose to manage polyglot services, with real-world examples, best practices, and troubleshooting tips for reliable deployments."
theme: "Cloud & DevOps"
---

> **Context:** Personal practice repo for learning how Docker + Compose handle Node + Python services; no production teams depend on this.  
> **AI assist:** Article scaffolded with ChatGPT using notes from the `docker_multilang_project` repo; I edited it on 2025-10-15.  
> **Status:** Student-level case study meant to document what works (and what still needs work) before I claim DevOps proficiency.

## TL;DR

- **Containers give polyglot teams a repeatable lab.** Packaging Node and Python in Docker erased “works on my machine” drift [^docker-docs][^redhat-comparison].  
- **Compose ties services together fast.** One YAML file spins up a networked stack, proves dependencies, and highlights isolation wins.  
- **Experiments surface behaviour differences.** Dependency failures, runtime patterns, and persistence tests stay scoped to the right container.  
- **Next move: automate everything.** Add health checks, CI pipelines, and eventually Kubernetes to scale the blueprint.

## Project Snapshot

- **Goal:** Ship a two-service project (Python calculations + Node API) with Docker, prove isolation, and rehearse failure recovery.  
- **Repository:** [github.com/BradleyMatera/docker_multilang_project](https://github.com/BradleyMatera/docker_multilang_project).  
- **Focus areas:** Dependency boundaries, service networking, and troubleshooting under load.

## Architecture & Files

**Project layout:**

```
docker_multilang_project/
├── docker-compose.yml
├── python-service/
│   ├── Dockerfile
│   └── app.py
└── node-service/
    ├── Dockerfile
    ├── package.json
    └── server.js
```

**Python service Dockerfile:**

```dockerfile
FROM python:3.11-slim
WORKDIR /app
COPY app.py .
CMD ["python", "app.py"]
```

**Node service Dockerfile:**

```dockerfile
FROM node:20-alpine
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY server.js .
EXPOSE 3000
CMD ["node", "server.js"]
```

**Compose orchestration:**

```yaml
version: "3.9"
services:
  python:
    build: ./python-service
    container_name: python-service
  node:
    build: ./node-service
    container_name: node-service
    ports:
      - "3000:3000"
    networks:
      - app-net
networks:
  app-net:
```

- Custom network keeps inter-service calls private, while port 3000 exposes the Node API to localhost.

## Experiments & Findings

1. **Dependency isolation:** Removing Express broke only the Node build, proving issues stay scoped to their service [^docker-best-practices].  
2. **Runtime behaviour:** Side-by-side loops highlighted synchronous Python vs asynchronous Node logs, reinforcing observability needs.  
3. **Persistence test:** Mounting `./logs:/app/logs` kept artifacts between restarts, while removing the volume confirmed default ephemerality [^docker-volumes].

## Results

- **Launch speed:** On my M2 laptop the containers boot in ~5 seconds; the older VirtualBox VMs I used for class easily took 30+ seconds (anecdotal but noticeable).  
- **Failure containment:** Induced infinite loops/crashes stayed inside the target container, which is exactly what I wanted to rehearse.  
- **Horizontal scaling:** `docker compose up --scale node=3` simulated concurrent calls without touching code, even if it’s still just localhost traffic.  
- **Troubleshooting toolkit:** `docker exec` shells and `docker logs` streams kept debugging fast; I document each command in the README for future me.

## Lessons & Next Steps

- **Containers ≠ VMs:** They share the host kernel, so mind OS compatibility (e.g., WSL on Windows) [^ibm-comparison].  
- **Secure builds:** Adopt multi-stage builds and vulnerability scans before production pushes [^docker-security].  
- **What’s next:** Add healthchecks, wire CI to build/push images, and explore Kubernetes once the stack needs orchestrated scaling.

## Key Takeaways

- **Compose is the on-ramp.** Start here to understand networking, volumes, and process isolation.  
- **Observability matters from day one.** Logs, probes, and volumes show whether services behave like you expect.  
- **Iterate toward production.** Layer automation, security, and orchestration as complexity grows.

[^docker-docs]: Docker. "What is a Container?" Accessed October 2025. https://www.docker.com/resources/what-container/.
[^redhat-comparison]: Red Hat. "Containers vs VMs." Accessed October 2025. https://www.redhat.com/en/topics/containers/containers-vs-vms.
[^docker-best-practices]: Docker. "Best Practices for Dockerfiles." Accessed October 2025. https://docs.docker.com/develop/develop-images/dockerfile_best-practices/.
[^docker-volumes]: Docker. "Use Volumes." Accessed October 2025. https://docs.docker.com/storage/volumes/.
[^ibm-comparison]: IBM. "Containers vs Virtual Machines." Accessed October 2025. https://www.ibm.com/cloud/blog/containers-vs-vms.
[^docker-security]: Docker. "Docker Security." Accessed October 2025. https://docs.docker.com/engine/security/.
