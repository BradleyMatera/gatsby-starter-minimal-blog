---
title: "Docker for Multi-Language Projects: Full Setup From Zero"
date: "2025-06-10"
description: "A complete lab guide for running two languages in one Docker setup with clear steps and verification."
slug: "/containerizing-multi-language-projects-with-docker-a-practical-guide"
tags: ["docker", "containerization", "web-development"]
theme: "Cloud & DevOps"
---

Running two languages in one repo can get messy fast.

This post is a full lab guide to keep the setup simple and repeatable.

You will build a two service setup with Docker and Compose.

If you are new to multi-service repos, this is for you.

## What this is

High level, Docker lets each service run in its own container.

Low level, you write a Dockerfile per service and a Compose file to run them together.

Key terms:

- **Dockerfile**: the build recipe for an image.
- **Image**: the built artifact that includes your app and dependencies.
- **Compose**: a YAML file that defines how services run together.

## What you need

- Docker Desktop installed.
- A repo with two folders, such as `api` and `web`.
- A terminal.

Docs used:

- https://docs.docker.com/build/
- https://docs.docker.com/compose/

## Start to finish

1) Create a Dockerfile for each service.

Why: Each service should build in isolation.

`api/Dockerfile` example:

```Dockerfile
FROM node:20-alpine
WORKDIR /app
COPY package.json package-lock.json ./
RUN npm ci
COPY . .
CMD ["npm", "run", "start"]
```

`web/Dockerfile` example:

```Dockerfile
FROM node:20-alpine
WORKDIR /app
COPY package.json package-lock.json ./
RUN npm ci
COPY . .
CMD ["npm", "run", "dev"]
```

2) Create `docker-compose.yml` at the repo root.

Why: Compose starts both services together.

```yaml
services:
  api:
    build: ./api
    ports:
      - "4000:4000"
  web:
    build: ./web
    ports:
      - "3000:3000"
    depends_on:
      - api
```

3) Build and run the stack.

Why: This confirms both services start.

```bash
docker compose up --build
```

4) Add a small note in README.

Why: You need steps anyone can repeat.

Example:

```md
## Run locally
- docker compose up --build
- open http://localhost:3000
```

## Verify it worked

- The web app opens at http://localhost:3000
- The API responds at http://localhost:4000
- `docker compose ps` shows both services running

If the API does not respond, check the container logs:

```bash
docker logs <container-id>
```

## Common mistakes

- **Symptom**: Build fails on npm install.
  **Cause**: Missing lockfile in the image.
  **Fix**: Copy `package-lock.json` before running `npm ci`.

- **Symptom**: Web app cannot reach API.
  **Cause**: Wrong host or port.
  **Fix**: Use the API service name from Compose.

- **Symptom**: Compose fails to start.
  **Cause**: YAML indentation errors.
  **Fix**: Re-check spaces and alignment.

## Cheat sheet

- One Dockerfile per service.
- One Compose file at the root.
- Build and run with `docker compose up --build`.
- Verify both ports respond.

## Next steps

- Add a health check route.
- Add a `.env` example file.
- Add a short troubleshooting section.

Related links:

- https://docs.docker.com/compose/
- https://docs.docker.com/build/

Final CTA:

If you want my example repo structure, ask and I will share it.
