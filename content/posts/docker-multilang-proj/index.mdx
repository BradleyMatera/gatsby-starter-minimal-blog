---
title: "Docker Multilang: One Compose File, Three Runtimes"
date: "2025-02-10"
slug: "/containerizing-multi-language-projects-with-docker-a-practical-guide"
tags: ["docker", "containers", "devops"]
description: "A concrete guide to containerizing a small multi-language project with exact files and commands."
theme: "DevOps"
---

Containers are simple when you keep the surface area small.

This post shows a minimal multi-language setup using Docker and Compose.

You will build a Node API, a Python worker, and a static frontend in one stack.

I cannot verify these steps from this blog repo. Treat this as a lab guide you can run locally.

## The promise

By the end, you will:

- run three services with one `docker compose up`
- understand how ports and networks line up
- verify each service with a concrete check

> "If each container has one job, Compose becomes easy to reason about."

## What this is

**High level:** Docker packages each service with its runtime so they run consistently.

**Low level:** You write a Dockerfile per service and a `docker-compose.yml` that wires ports and dependencies.

**Key terms:**

- **Image:** A packaged filesystem and runtime.
- **Container:** A running instance of an image.
- **Compose:** A config file that runs multiple containers together.

## What you need

- Docker Desktop installed
- Node 18
- Python 3.11

## Start to Finish

### Step 1: Create the project layout
Goal:
Create a folder structure that separates services.

Actions:
- Commands:
  ```bash
  mkdir multilang && cd multilang
  mkdir api worker web
  ```
- File tree:
  ```text
  multilang/
    api/
    worker/
    web/
  ```

Why:
Clear folders keep Dockerfiles simple and predictable. Each folder becomes a build context. This avoids accidental file leaks into images. It also makes it easy to reason about which service owns which code.

Verify:
- Run:
  ```bash
  ls
  ```
- Expected: `api`, `worker`, and `web` directories.
- This confirms the structure is in place.

If it fails:
- Symptom: missing folder.
- Fix: re run the `mkdir` commands.

### Step 2: Add the Node API
Goal:
Create a minimal Node API that responds on `/health`.

Actions:
- File path: `api/index.js`
- Add:
  ```js
  const express = require("express");
  const app = express();
  app.get("/health", (_req, res) => res.json({ ok: true }));
  app.listen(3001, () => console.log("api on 3001"));
  ```
- File path: `api/package.json`
- Add:
  ```json
  {
    "name": "api",
    "version": "1.0.0",
    "main": "index.js",
    "scripts": {
      "start": "node index.js"
    },
    "dependencies": {
      "express": "^4.19.2"
    }
  }
  ```
- Command:
  ```bash
  cd api && npm install
  ```

Why:
A health route is the simplest verification check. Express keeps the example short. Having a fixed port is important for Compose mapping. This step establishes one running service in the stack.

Verify:
- Run locally:
  ```bash
  npm start
  ```
- Expected output: `api on 3001`.
- This confirms the API starts.

If it fails:
- Symptom: `Cannot find module 'express'`.
- Fix: run `npm install` in `api/`.

### Step 3: Add the Python worker
Goal:
Create a Python script that prints a heartbeat.

Actions:
- File path: `worker/main.py`
- Add:
  ```py
  import time

  while True:
      print("worker alive")
      time.sleep(5)
  ```
- File path: `worker/requirements.txt`
- Add:
  ```text
  ```

Why:
The worker does not need a server. A loop proves it is running. This keeps the example focused on multi runtime containers. You can replace the worker with real jobs later.

Verify:
- Run:
  ```bash
  python3 worker/main.py
  ```
- Expected output: `worker alive` every 5 seconds.
- This confirms the worker runs.

If it fails:
- Symptom: `python3: command not found`.
- Fix: install Python 3.11.

### Step 4: Add a static web page
Goal:
Create a tiny static site to serve.

Actions:
- File path: `web/index.html`
- Add:
  ```html
  <h1>Multilang Demo</h1>
  <p>If you see this, the web container works.</p>
  ```

Why:
A static page verifies your web container without extra tooling. It keeps the stack small. You can replace it with a real frontend later. This makes the web service easy to test.

Verify:
- Open the file in a browser.
- Expected: the heading and paragraph show.
- This confirms the file renders.

If it fails:
- Symptom: blank page.
- Fix: check the file path and content.

### Step 5: Add Dockerfiles
Goal:
Create one Dockerfile per service.

Actions:
- File path: `api/Dockerfile`
  ```dockerfile
  FROM node:18-alpine
  WORKDIR /app
  COPY package.json package-lock.json ./
  RUN npm install --production
  COPY . .
  EXPOSE 3001
  CMD ["npm", "start"]
  ```
- File path: `worker/Dockerfile`
  ```dockerfile
  FROM python:3.11-slim
  WORKDIR /app
  COPY requirements.txt ./
  RUN pip install -r requirements.txt
  COPY . .
  CMD ["python", "main.py"]
  ```
- File path: `web/Dockerfile`
  ```dockerfile
  FROM nginx:alpine
  COPY index.html /usr/share/nginx/html/index.html
  ```

Why:
Each Dockerfile describes one runtime. Small base images keep builds fast. Copying only required files reduces noise. Exposing the API port makes the mapping explicit.

Verify:
- Build one image:
  ```bash
  docker build -t multilang-api api
  ```
- Expected: build completes without errors.
- This confirms the Dockerfile is valid.

If it fails:
- Symptom: missing `package-lock.json`.
- Fix: run `npm install` in `api/` or update the COPY line.

### Step 6: Add Compose
Goal:
Run all services with one command.

Actions:
- File path: `docker-compose.yml`
- Add:
  ```yaml
  services:
    api:
      build: ./api
      ports:
        - "3001:3001"
    worker:
      build: ./worker
    web:
      build: ./web
      ports:
        - "8080:80"
  ```
- Command:
  ```bash
  docker compose up --build
  ```

Why:
Compose maps your services to ports and builds them together. This is the simplest way to run three containers in one stack. Keeping the file short avoids hidden behavior. You can add networks and env later.

Verify:
- Open http://localhost:8080
- Expected: "Multilang Demo" page.
- Run:
  ```bash
  curl http://localhost:3001/health
  ```
- Expected: `{ "ok": true }`
- This confirms the web and API containers run.

If it fails:
- Symptom: port already in use.
- Fix: change the host ports in `docker-compose.yml`.

## Verify it worked

- Web page loads on port 8080.
- API health returns JSON on port 3001.
- Worker logs show "worker alive" every 5 seconds.

## Common mistakes

- **Symptom:** API container exits instantly.  
  **Cause:** `npm install` did not run.  
  **Fix:** rebuild with `docker compose up --build`.

- **Symptom:** Web page 404.  
  **Cause:** Nginx did not receive the `index.html`.  
  **Fix:** confirm the COPY path in the web Dockerfile.

- **Symptom:** Worker spams errors.  
  **Cause:** Python file name mismatch.  
  **Fix:** ensure `main.py` exists in `worker/`.

## Cheat sheet

- One Dockerfile per service.
- One port per public service.
- Compose runs everything.
- Verify with curl and a browser.

## Next steps

- Add environment variables for config.
- Add a shared network and service names.
- Add health checks in Compose.

## Related links

- https://docs.docker.com/compose/
- https://docs.docker.com/build/

## Final CTA

Build one service at a time, then compose them together.
