---
title: "JWT CTF Lab: Build, Decode, and Verify Tokens"
date: "2025-08-10"
slug: "/jwt-ctf-lab"
tags: ["security", "jwt", "ctf"]
description: "A full JWT lab guide with exact steps, commands, and verification checks."
theme: "Security"
---

JWTs are simple until you trust them without verifying.

This lab walks through creating, decoding, and validating a JWT.

You will build a tiny token workflow and verify each step.

I cannot verify these steps from this blog repo. Treat this as a lab guide you can run locally.

## The promise

By the end, you will:

- generate a JWT
- decode it safely
- verify its signature

> "If you do not verify the signature, the token is just a string."

## What this is

**High level:** JWT is a signed token format used for auth and claims.

**Low level:** You sign a JSON payload with a secret, then verify that signature on decode.

**Key terms:**

- **JWT:** JSON Web Token.
- **Header:** The token metadata.
- **Payload:** The claims inside the token.
- **Signature:** The cryptographic proof the token was not modified.

## What you need

- Node 18+
- A terminal
- A new folder for the lab

## Start to Finish

### Step 1: Create the lab project
Goal:
Set up a minimal Node project for the JWT lab.

Actions:
- Commands:
  ```bash
  mkdir jwt-lab && cd jwt-lab
  npm init -y
  npm install jsonwebtoken
  ```
- File path: `index.js`

Why:
A clean folder keeps the lab isolated. `jsonwebtoken` gives you signing and verification in a few lines. This keeps the example focused. It also makes it easy to delete later.

Verify:
- Run:
  ```bash
  npm list jsonwebtoken
  ```
- Expected: `jsonwebtoken` appears.
- This confirms the dependency is installed.

If it fails:
- Symptom: `jsonwebtoken` missing.
- Fix: run `npm install jsonwebtoken` again.

### Step 2: Sign a token
Goal:
Generate a JWT with a known payload.

Actions:
- File path: `index.js`
- Add:
  ```js
  const jwt = require("jsonwebtoken");

  const secret = "demo-secret";
  const payload = { userId: "123", role: "user" };

  const token = jwt.sign(payload, secret, { expiresIn: "1h" });
  console.log("token:", token);
  ```

Why:
You need a real token to test. A short payload is easy to inspect. A fixed secret keeps the lab deterministic. Expiration helps demonstrate validation later.

Verify:
- Run:
  ```bash
  node index.js
  ```
- Expected: a long token string printed to the console.
- This confirms the token is generated.

If it fails:
- Symptom: `jwt.sign is not a function`.
- Fix: check the import and package install.

### Step 3: Decode the token
Goal:
Inspect the token without verifying it yet.

Actions:
- File path: `index.js`
- Add after signing:
  ```js
  const decoded = jwt.decode(token, { complete: true });
  console.log("decoded:", decoded);
  ```

Why:
Decoding shows the header and payload. This proves what is inside the token. It also shows why decoding alone is not enough for trust. This step is the baseline for the next verification step.

Verify:
- Run `node index.js`.
- Expected: `header` and `payload` printed.
- This confirms the decode works.

If it fails:
- Symptom: `decoded` is null.
- Fix: ensure the token string is passed correctly.

### Step 4: Verify the signature
Goal:
Verify the token with the correct secret.

Actions:
- File path: `index.js`
- Add:
  ```js
  try {
    const verified = jwt.verify(token, secret);
    console.log("verified:", verified);
  } catch (err) {
    console.error("verify failed:", err.message);
  }
  ```

Why:
Verification is the security step. It proves the token was signed with the secret. Without this, any attacker can forge a token. This is the part that turns the JWT into a trustworthy claim.

Verify:
- Run `node index.js`.
- Expected: `verified` object printed with `userId` and `role`.
- This confirms the signature is valid.

If it fails:
- Symptom: `invalid signature`.
- Fix: ensure the secret used to verify matches the secret used to sign.

## Verify it worked

- A token prints.
- The token decodes into header and payload.
- Verification returns the payload without errors.

## Common mistakes

- **Symptom:** Verification fails with `invalid signature`.  
  **Cause:** Secret mismatch.  
  **Fix:** use the same secret for signing and verifying.

- **Symptom:** Token expires immediately.  
  **Cause:** Bad `expiresIn` value.  
  **Fix:** use `1h` or a numeric value in seconds.

- **Symptom:** You trust decoded tokens without verifying.  
  **Cause:** Misunderstanding of JWT.  
  **Fix:** always call `verify`.

## Cheat sheet

- Sign with a secret.
- Decode for visibility.
- Verify for trust.

## Next steps

- Add a refresh token flow.
- Store the token securely in memory only for demos.

## Related links

- https://jwt.io/
- https://github.com/auth0/node-jsonwebtoken

## Final CTA

If you do not verify the token, you do not have security.
