---
title: "A Deep Dive into JSON Web Tokens: My Journey Through a CTF Challenge"
date: "2024-12-16"
description: "How I decrypted, explored, and used JSON Web Tokens (JWTs) to solve a CTF challenge, including obstacles I encountered and lessons learned."
tags: ["JWT", "CTF", "Web Tokens", "gRPC", "JSON", "Encryption"]
---

## Introduction

During a winter Capture the Flag event I tackled a puzzle that chained together symmetric encryption, JSON Web Tokens (JWTs), and gRPC endpoints. My objective was not only to retrieve hidden flags but to strengthen my understanding of token-based authentication and remote procedure calls. This post summarises the challenge at a conceptual level, clarifies what JWTs and gRPC actually are, and captures the lessons I would share with teammates approaching similar infrastructure.

## Background Concepts

### JSON Web Tokens
A JSON Web Token is a compact, URL-safe token that carries claims between two parties.[^jwt-spec] A token comprises a header (algorithm and type), a payload (claims such as `sub` or `exp`), and a signature that verifies integrity. Importantly, the header and payload are merely Base64URL-encoded; anyone can decode them, so they must never contain secrets or personal data.[^jwt-claims]

### gRPC in Brief
gRPC is a high-performance, open-source RPC framework that uses HTTP/2 as a transport layer and Protocol Buffers for data serialisation.[^grpc] It supports unary and streaming calls, enforces strict content types (`application/grpc`), and can be fronted by load balancers that terminate TLS.

Understanding these two technologies up front made the CTF manageable: tokens provide access, while gRPC enforces transport constraints.

## Challenge Workflow

1. **Initial token discovery** – The organisers supplied a `token.md` file containing a bootstrap token (`PAGE_TOKEN`).  
2. **Decrypting ciphertexts** – A `secretbox.md` file included Base64-encoded ciphertext, a key, and a nonce. Using Libsodium’s `secretbox_open` I decrypted the payload and obtained a signed JWT (`JWT_TOKEN`).  
3. **Authorising API calls** – Passing `JWT_TOKEN` as a Bearer token to `token.v1.TokenService/GetToken` returned an intermediate token (`CONNECT_UNARY_TOKEN`). Each token validated the previous step, similar to chained OAuth scopes.  
4. **Streaming endpoint attempts** – Using `grpcurl` and a Python client I contacted `StreamToken`, this time authorised with `CONNECT_UNARY_TOKEN` or an additional secret (`NA_CL_SECRET_TOKEN`). The server responded with HTTP 464 errors, indicating the load balancer rejected the request before it reached the service. That hinted at content-type mismatches or missing TLS metadata.

Rather than documenting every curl command, I distilled the workflow into reusable snippets and notes in a scratchpad. The key commands are reproduced in my GitHub Gist (linked from the portfolio) for peers who want to replay the challenge with their own credentials.

## Lessons Learned About JWTs

1. **JWTs are signed, not encrypted.** Anyone can decode the header and payload, so sensitive data must remain elsewhere.[^jwt-claims]  
2. **Always verify the signature.** The token is trustworthy only if the recipient validates the signature using the shared secret or public key. In the challenge the service performed this verification when I called `GetToken`.  
3. **Short-lived scopes reduce risk.** Each token unlocked the next step, and rotatable keys (nonce + key pairs) limited exposure. This mirrors best practice for issuing scoped access tokens in production.

## Lessons Learned About gRPC

1. **Content-type matters.** gRPC expects `application/grpc` over HTTP/2.[^grpc] When I hit the endpoint with `application/json`, the proxy returned HTTP 464.  
2. **Load balancers can mask errors.** AWS Elastic Load Balancers may translate gRPC errors into HTTP status codes, so pairing `grpcurl` with verbose logs is essential.  
3. **Metadata formatting is strict.** Authorisation headers must be lowercase (`authorization`) in gRPC metadata; otherwise they are discarded silently.

## Tools and Techniques

| Tool | Purpose | Notes |
| --- | --- | --- |
| Libsodium `secretbox_open` | Decrypt XSalsa20-Poly1305 ciphertext | Required correct nonce and key order. |
| `jwt.io` decoder | Inspect token payloads | Helpful for quick sanity checks. |
| `grpcurl` | Exercise unary and streaming calls | `--cacert` ensured TLS trust; `-H "authorization: Bearer …"` set metadata. |
| Python gRPC client | Programmatic retries and logging | Provided better stack traces than CLI tools. |
| Wireshark & `openssl s_client` | Verified TLS negotiation | Confirmed that HTTP/2 multiplexing stayed intact. |

## What I Would Do Differently Next Time

- **Automate signature checks.** I manually verified signatures during the event. Next time I’ll script verification with libraries like `pyjwt` so I can move faster under time pressure.  
- **Capture headers and payloads in fixtures.** Having structured fixtures would make it easier to write regression tests and teach others.  
- **Experiment with gRPC-Web.** Some load balancers support gRPC-Web over HTTP/1.1; testing that path could uncover alternate solutions when HTTP/2 is blocked.

## Conclusion

This CTF reinforced how authentication chains and RPC transport rules intersect. By decoding JWTs carefully, validating signatures, and respecting gRPC’s metadata requirements, I progressed through most of the challenge. The remaining obstacles—largely load balancer behaviours—highlighted the importance of observability and protocol knowledge. Those skills translate directly into production environments where token misuse or misconfigured proxies can quickly derail deployments.

## References

[^jwt-spec]: IETF, “JSON Web Token (JWT),” RFC 7519, May 2015, https://www.rfc-editor.org/rfc/rfc7519.  
[^jwt-claims]: Auth0 Documentation, “JWT Anatomy,” accessed March 2025, https://auth0.com/learn/json-web-tokens/.  
[^grpc]: CNCF, “gRPC Concepts,” accessed March 2025, https://grpc.io/docs/what-is-grpc/introduction/.
