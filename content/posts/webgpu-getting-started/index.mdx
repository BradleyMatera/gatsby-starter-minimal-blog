---
title: "WebGPU Triangle Demo: Start, Fix, and Keep It Honest"
date: "2025-07-22"
slug: "/webgpu-getting-started"
tags: ["webgpu", "graphics", "learning"]
description: "A complete, minimal WebGPU triangle guide with setup, fixes, and verification."
theme: "Graphics"
---

WebGPU looks scary until you ship one triangle.

This is a combined guide that covers the minimal start, the rebuild fixes, and the honesty audit.

You will get a working setup, the exact steps, and a clear checklist to keep the write up honest.

If you only build one WebGPU thing, build this.

## The promise

By the end, you will:

- understand what WebGPU actually is
- render a triangle with a minimal pipeline
- debug common setup failures without guessing

> "One triangle is enough to learn the pipeline."

## What this is

**High level:** WebGPU is the browser API for modern GPU access. It lets you submit commands to the GPU for fast graphics work.

**Low level:** You request a GPU adapter, create a device, define a render pipeline, and issue a draw call into a canvas context.

**Key terms:**

- **Adapter:** The GPU driver entry point that tells you what the system supports.
- **Device:** The object you use to create buffers, shaders, and pipelines.
- **Pipeline:** The configuration that connects your shaders to the GPU render stages.

## What you need

- A browser that supports WebGPU (Chrome or Edge stable)
- A simple static site or local dev server
- A single HTML file and one JS file

If WebGPU is disabled, you will need to turn it on in `chrome://flags`.

## Start to finish

1. **Create the HTML shell.**
   The canvas is the only required element.

   ```html
   <canvas id="gfx" width="640" height="360"></canvas>
   <script type="module" src="main.js"></script>
   ```

2. **Request the adapter and device.**
   This is the minimum handshake.

   ```js
   const adapter = await navigator.gpu.requestAdapter();
   if (!adapter) throw new Error("No GPU adapter");
   const device = await adapter.requestDevice();
   ```

3. **Create the canvas context.**
   You must configure it with the preferred format.

   ```js
   const canvas = document.getElementById("gfx");
   const context = canvas.getContext("webgpu");
   const format = navigator.gpu.getPreferredCanvasFormat();
   context.configure({ device, format, alphaMode: "opaque" });
   ```

4. **Define a minimal shader.**
   Use WGSL with a hard coded triangle.

   ```wgsl
   @vertex
   fn vs_main(@builtin(vertex_index) vi: u32) -> @builtin(position) vec4f {
     var positions = array<vec2f, 3>(
       vec2f(0.0, 0.6),
       vec2f(-0.6, -0.6),
       vec2f(0.6, -0.6)
     );
     return vec4f(positions[vi], 0.0, 1.0);
   }

   @fragment
   fn fs_main() -> @location(0) vec4f {
     return vec4f(0.2, 0.6, 1.0, 1.0);
   }
   ```

5. **Create the pipeline.**
   This binds the shader to the render pass.

   ```js
   const module = device.createShaderModule({ code: shaderCode });
   const pipeline = device.createRenderPipeline({
     layout: "auto",
     vertex: { module, entryPoint: "vs_main" },
     fragment: { module, entryPoint: "fs_main", targets: [{ format }] },
     primitive: { topology: "triangle-list" }
   });
   ```

6. **Draw the frame.**
   This is the minimal render loop.

   ```js
   function frame() {
     const encoder = device.createCommandEncoder();
     const pass = encoder.beginRenderPass({
       colorAttachments: [{
         view: context.getCurrentTexture().createView(),
         clearValue: { r: 0.05, g: 0.05, b: 0.08, a: 1 },
         loadOp: "clear",
         storeOp: "store"
       }]
     });
     pass.setPipeline(pipeline);
     pass.draw(3);
     pass.end();
     device.queue.submit([encoder.finish()]);
     requestAnimationFrame(frame);
   }
   frame();
   ```

7. **Write the honesty note.**
   If you share this, say exactly what it does and what it does not.

   ```text
   What works: One triangle, one pipeline, one draw call.
   What is next: Resize handling and input controls.
   ```

## Verify it worked

- The canvas shows a triangle on a dark background.
- The browser console has no WebGPU errors.
- The frame loop runs without throwing.

If you do not see a triangle, check the console first. Most failures are misconfigured context or shader errors.

## Common mistakes

- **Symptom:** `navigator.gpu` is undefined.  
  **Cause:** WebGPU is not enabled or the browser is too old.  
  **Fix:** Update the browser and enable WebGPU in flags.

- **Symptom:** Clear color shows but no triangle.  
  **Cause:** Shader compile error or wrong entry point names.  
  **Fix:** Ensure `vs_main` and `fs_main` match your pipeline config.

- **Symptom:** Canvas is blank and console shows device lost.  
  **Cause:** GPU reset or driver issue.  
  **Fix:** Reload the page or try a different GPU.

## Cheat sheet

- Request adapter and device.
- Configure the canvas with the preferred format.
- Build a pipeline with WGSL.
- Draw 3 vertices.
- Keep your write up strict and honest.

## Next steps

- Add a resize handler.
- Add a uniform buffer for color.
- Export this demo as a static page.

## Related links

- https://developer.chrome.com/docs/web-platform/webgpu/
- https://www.w3.org/TR/webgpu/
- https://github.com/BradleyMatera/TriangleDemo
- https://bradleymatera.github.io/TriangleDemo/

## Final CTA

Ship one triangle, then build one small improvement. Do not skip the verify step.
