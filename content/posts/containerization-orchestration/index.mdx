---
title: "Venturing Beyond Hello World: Mastering Containerization and Orchestration"
date: "2025-08-04"
slug: "/containerization-and-orchestration"
tags: ["Docker", "Kubernetes", "DevOps", "Infrastructure"]
description: "Embark on my journey from simple container experiments to orchestrating complex, production-ready deployments with Docker Compose and Amazon EKS."
theme: "Cloud & DevOps"
---

## TL;DR

- **Compose first, Kubernetes next.** Local fleets start with Docker Compose, then graduate to EKS when workloads need autoscaling muscle [^compose][^kubernetes].  
- **Observability is cargo.** Structured logs, health probes, and chaos drills uncover weak links before production does.  
- **Infrastructure as code keeps crews synced.** Terraform, CI pipelines, and GitOps guarantee clusters match source control.  
- **Lean images and automation cut cost.** Multi-stage builds, security scans, and spot instances reduce waste without sacrificing reliability.

## From Hello World to Fleet Operations

- Began with single-container Python and Node demos, then expanded into a three-service stack (`frontend`, `api`, `db`).  
- Optimised each image with multi-stage builds, health checks, and persistent volumes to keep local resilience high.  
- Sharing the environment became trivial—every teammate could run `docker compose up` to match production assumptions [^compose].

## Compose Foundations

**docker-compose.yml highlights:**

```yaml
version: "3.9"
services:
  api:
    build: ./api
    env_file: .env.api
    depends_on: [db]
    ports: ["4000:4000"]
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:4000/healthz"]
      interval: 30s
      retries: 3

  frontend:
    build:
      context: ./frontend
      target: production
    ports: ["8080:80"]
    depends_on: [api]

  db:
    image: postgres:15
    volumes:
      - pgdata:/var/lib/postgresql/data
    environment:
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
volumes:
  pgdata:
```

- Health checks gate traffic, Postgres volumes persist data, and env files keep secrets out of the compose file.

## Observability & Resilience

- **Structured logging:** JSON logs with correlation IDs feed Logstash/CloudWatch to trace entire requests.  
- **Health probes:** Separate readiness and liveness endpoints tell orchestrators when to route traffic.  
- **Chaos drills:** Kill containers with `docker compose kill api` to validate graceful degradation paths.

## Kubernetes on Amazon EKS

- **Provision with Terraform:** Define clusters, node groups, VPCs, and IAM roles as code for reviewable changes.  
- **Deploy with manifests:** Each service owns a Deployment, Service, HPA, ConfigMap, and Secret boundary.  
- **Ingress & security:** AWS Load Balancer Controller provisions TLS-enabled ALBs; secrets stay in AWS Secrets Manager.  
- **Observability stack:** Prometheus + Grafana watch latency/resources while Fluent Bit ships logs to CloudWatch.

**Deployment snippet:**

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: api
spec:
  replicas: 3
  selector:
    matchLabels:
      app: api
  template:
    metadata:
      labels:
        app: api
    spec:
      containers:
        - name: api
          image: $ECR_URI/api:${GITHUB_SHA}
          ports:
            - containerPort: 4000
          envFrom:
            - secretRef:
                name: api-secrets
          readinessProbe:
            httpGet:
              path: /ready
              port: 4000
            initialDelaySeconds: 5
            periodSeconds: 10
```

- Autoscaling and rolling upgrades kept throughput stable while reducing manual intervention.

## Lessons from the Voyage

1. **Compose is the sandbox; Kubernetes is the stadium.** Start small, then upgrade once you need automation and autoscaling [^kubernetes].  
2. **Slim images matter.** Multi-stage builds and distroless bases shrink attack surfaces and boost cold-start speed.  
3. **Automate deployments.** CI pipelines build, scan (Trivy), push to ECR, and deploy via `kubectl` or Argo CD.  
4. **Monitor costs.** Track node-hours, enable autoscaling, and mix in spot capacity to avoid surprise invoices.

## Key Takeaways

- **Documentation is your map.** Write runbooks, diagrams, and README updates before the next storm hits.  
- **Health signals prevent firefights.** Treat logs, metrics, and probes as critical application features.  
- **Future focus:** Explore App Mesh and policy-as-code to standardise reliability and security across the fleet.

[^compose]: Docker Documentation, “Overview of Docker Compose,” accessed May 2025, https://docs.docker.com/compose/.
[^kubernetes]: Kubernetes Documentation, “Production Considerations,” accessed May 2025, https://kubernetes.io/docs/setup/production-environment/.
