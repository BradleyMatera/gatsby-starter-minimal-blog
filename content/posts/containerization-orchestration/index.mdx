---
title: "Containerization and Orchestration: A Small Lab You Can Run"
date: "2025-06-22"
slug: "/containerization-and-orchestration"
tags: ["docker", "kubernetes", "devops"]
description: "A minimal container lab plus a small orchestration step with exact commands."
theme: "DevOps"
---

Containerization is easier when you keep the stack small.

This post shows one container and one orchestration step you can verify.

You will build a container and run it under Compose.

I cannot verify these steps from this blog repo. Treat this as a lab guide you can run locally.

## The promise

By the end, you will:

- build one container image
- run it with Compose
- verify the service is healthy

> "Orchestration is just a repeatable run command."

## What this is

**High level:** Containerization packages your app, orchestration runs it consistently.

**Low level:** You write a Dockerfile, then use Compose to run it with ports.

**Key terms:**

- **Dockerfile:** Build instructions for an image.
- **Compose:** A YAML file that runs containers together.
- **Port mapping:** The link between host and container ports.

## What you need

- Docker Desktop
- A small web server app

## Start to Finish

### Step 1: Create the app
Goal:
Create a tiny web server that returns a health response.

Actions:
- File path: `app/index.js`
- Add:
  ```js
  const express = require("express");
  const app = express();
  app.get("/health", (_req, res) => res.json({ ok: true }));
  app.listen(3000, () => console.log("server on 3000"));
  ```
- File path: `app/package.json`
- Add:
  ```json
  {
    "name": "app",
    "version": "1.0.0",
    "main": "index.js",
    "scripts": { "start": "node index.js" },
    "dependencies": { "express": "^4.19.2" }
  }
  ```
- Command:
  ```bash
  cd app && npm install
  ```

Why:
A health route is a clean verification step. Express makes the app tiny. This keeps the lab focused on containers, not frameworks. A small app is easier to debug.

Verify:
- Run:
  ```bash
  npm start
  ```
- Expected: `server on 3000`.
- This confirms the app works.

If it fails:
- Symptom: module not found.
- Fix: run `npm install`.

### Step 2: Add a Dockerfile
Goal:
Package the app into a container image.

Actions:
- File path: `app/Dockerfile`
- Add:
  ```dockerfile
  FROM node:18-alpine
  WORKDIR /app
  COPY package.json package-lock.json ./
  RUN npm install --production
  COPY . .
  EXPOSE 3000
  CMD ["npm", "start"]
  ```

Why:
The Dockerfile defines how the image is built. Using a small base image keeps builds fast. Exposing the port documents the service. This is the minimum to containerize a Node app.

Verify:
- Run:
  ```bash
  docker build -t lab-app app
  ```
- Expected: build completes without errors.
- This confirms the Dockerfile works.

If it fails:
- Symptom: missing `package-lock.json`.
- Fix: run `npm install` to generate it.

### Step 3: Orchestrate with Compose
Goal:
Run the container with a repeatable command.

Actions:
- File path: `docker-compose.yml`
- Add:
  ```yaml
  services:
    app:
      build: ./app
      ports:
        - "3000:3000"
  ```
- Command:
  ```bash
  docker compose up --build
  ```

Why:
Compose turns the run command into config. This makes it repeatable. It also makes it easy to add more services later. For a small lab, this is enough orchestration.

Verify:
- Run:
  ```bash
  curl http://localhost:3000/health
  ```
- Expected: `{ "ok": true }`.
- This confirms the container is running.

If it fails:
- Symptom: connection refused.  
  **Fix:** check port mapping and ensure the container is running.

## Verify it worked

- `docker compose up` runs.
- `/health` returns JSON.
- Logs show the server started.

## Common mistakes

- **Symptom:** Container exits immediately.  
  **Cause:** The command is wrong.  
  **Fix:** use `npm start` and ensure it exists.

- **Symptom:** Port not reachable.  
  **Cause:** No port mapping.  
  **Fix:** add `3000:3000` in Compose.

- **Symptom:** Build fails.  
  **Cause:** Missing lockfile.  
  **Fix:** run `npm install` and rebuild.

## Cheat sheet

- Build a tiny app.
- Write a Dockerfile.
- Run with Compose.
- Verify with curl.

## Next steps

- Add a second service.
- Add a health check in Compose.

## Related links

- https://docs.docker.com/compose/

## Final CTA

Keep the lab small and verify every step.
