---
title: "Technical Stack 2025: A Verifiable Inventory"
date: "2025-10-12"
slug: "/technical-stack-2025"
tags: ["stack", "process", "documentation"]
description: "A simple way to document what you actually use and what you are still learning."
theme: "Process"
---

If 2024 was the year of "AI Hype," 2025 was the year the dust finally settled. We stopped asking *if* AI would replace us and started asking *how* we could use it to ship faster than ever before.

Looking back at the code I wrote over the last 12 months, a pattern emerges. The fragmentation of the early 2020s—where every week brought a new framework—has collapsed into a highly efficient, opinionated "Meta Stack." We aren't fighting over tools anymore; we are fighting over shipping.

This isn't just a list of libraries. This is a breakdown of how web development actually felt in 2025, the stack that survived the hype cycle, and why I (mostly) stopped worrying about the next big thing.

## 1. The "Post-React" Era: Server Components Won

For years, React Server Components (RSC) were a controversial, confusing mess. In 2025, they finally clicked.

I spent the first half of the year trying to avoid the Next.js App Router, clinging to the simplicity of `useEffect` and client-side fetching. But by Q3, I capitulated. The mental model shifted. We stopped building "Client Apps that fetch data" and started building "Server Apps that sprinkle interactivity."

### The Big Shift
* **Data Fetching:** I haven't written a `useEffect` to fetch data in six months. Direct database calls in async Server Components became the standard. It eliminates the "loading spinner hell" of 2023.
* **Server Actions:** We stopped building dedicated API routes for simple mutations. Passing a function directly to a form action `<form action={updateUser}>` felt like PHP in 2005, but with full type safety. It is pragmatic and it works.

**The Verdict:** React 19 didn't kill other frameworks, but it made React feel less like a library and more like a full architecture. You either bought into the ecosystem (Next.js/Remix) or you left for something lighter like Svelte 5.

## 2. The Database is Just an URL (Postgres is King)

In 2025, the debate between SQL and NoSQL effectively ended for general-purpose apps. The winner wasn't just "SQL," it was **"Serverless Postgres."**

I used **Supabase** and **Neon** almost exclusively this year. The friction of setting up a Docker container or managing an RDS instance is gone. You get a connection string, you paste it into your `.env`, and you have a scalable, branching database instantly.

### Why this stuck
* **Drizzle ORM:** This was the breakout star of 2025. Prisma was great, but it was heavy. Drizzle gave us the SQL-like control we wanted with zero runtime overhead. Writing `db.select().from(users)` felt closer to the metal, and the TypeScript inference was magical.
* **The Death of "Global State":** Because Server Components allow us to fetch data right where we need it, the complex Redux/Zustand global stores shrank. We let the database be the state manager.

## 3. AI Didn't Replace Us, But It Changed "Coding"

This is the uncomfortable truth: I wrote significantly less boilerplate code in 2025.

Tools like **Cursor** (the VS Code fork) and **v0** (for UI generation) became non-negotiable. My workflow shifted from "Typing syntax" to "Architectural Review."

* **The New Workflow:** I don't type out a Tailwind card component anymore. I prompt v0: *"Give me a dashboard card with a sparkline chart and a glassmorphism effect,"* copy the code, and refine it.
* **The Danger:** The "Junior Developer Gap" widened. It is easier than ever to *generate* code, but harder than ever to *understand* it. I spent more time debugging subtle hallucinations in AI-generated logic than I did writing logic from scratch. But the velocity increase was undeniable.

## 4. The Runtime Wars: Bun vs. Node

Node.js is still the reliable grandfather, but **Bun** became my default for local development and scripting.

Why? **Speed.**
`bun install` is instant. `bun run dev` is instant. The built-in support for TypeScript/JSX without configuration meant I stopped wrestling with `tsconfig.json` and Webpack. While I still deploy to Node environments (mostly on Vercel or AWS Lambda), my local machine runs Bun. It is the quality-of-life upgrade we desperately needed.

## 5. CSS is Solved (Tailwind v4)

I haven't written a pure CSS file in 2025. **Tailwind CSS v4** (the Rust-based engine) launched and made the "it's too slow" argument irrelevant.

We also saw the rise of "Copy-Paste UI" libraries like **shadcn/ui**. We moved away from heavy component libraries (MUI, Bootstrap) that lock you into their design system. Instead, we want *code* we can own. 2025 was about owning your UI components but not writing them from scratch.

## 6. The "Self-Host" Renaissance

Perhaps as a reaction to rising cloud costs, 2025 saw a massive surge in "PaaS-on-your-own-server" tools like **Coolify**.

While Vercel is still the default for "getting it live," I moved several long-running background workers and heavy projects to a $5 Hetzner VPS running Coolify. It is the Heroku experience, but you own the data. It felt like reclaiming a bit of the internet from the giants.

## Summary: The "Default" Stack of 2025

If I started a new SaaS product today, I wouldn't spend a second debating the stack. This is the consensus architecture that dominated my year:

* **Framework:** Next.js (App Router)
* **Language:** TypeScript (Strict Mode)
* **Database:** Postgres (Neon/Supabase) via Drizzle ORM
* **Styling:** Tailwind CSS + shadcn/ui
* **Auth:** Auth.js (formerly NextAuth) or Clerk
* **Runtime:** Bun (Local), Node/Edge (Prod)

2025 wasn't about discovery; it was about convergence. We stopped experimenting with the "how" so we could finally focus on the "what."

---

### Author Bio

**Bradley Matera**
*I build real working systems with AI support, AWS knowledge, and repetition. I’m not a theory-heavy engineer. I learn through debugging, deployments, and shipping things people can actually click on.*