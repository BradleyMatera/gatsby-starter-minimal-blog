---
title: "Building a React CRUD App with AWS API Gateway"
date: "2024-05-16"
slug: "/projects/react-anime-crud-app"
tags: ["Projects", "React", "AWS API Gateway", "CRUD"]
description: "How I wired a React SPA to AWS API Gateway and Lambda, secured the endpoints, and handled rich character data with client-side filtering and error recovery."
theme: "Front-End & Full-Stack"
---

## TL;DR

- **Anime CRUD pairs React with AWS API Gateway + Lambda.** The SPA catalogs anime characters, while serverless endpoints handle persistence.  
- **Security starts at the edge.** Vercel injects API keys server-side; Lambda validates payloads and throttles misuse.  
- **UX stays responsive via optimistic updates and memoised filters.** Users see changes instantly even during cold starts.  
- **Future roadmap:** Auth, S3 uploads, offline support, and Terraform modules.

- **Live demo:** https://cruddemo-one.vercel.app/  
- **Code tour:** https://github.com/BradleyMatera/ReactJSMobileApp (private repo; structure below)

## Architecture Snapshot

- **Frontend:** React 18 with hooks, Vite/Webpack bundling, controlled forms, modals, filtering, optimistic updates.  
- **Backend:** AWS API Gateway routes to Lambda (Node.js) for CRUD against DynamoDB.  
- **External data:** [Jikan API](https://jikan.moe/) supplies trending metadata.  
- **Hosting:** Vercel for the SPA, AWS for serverless endpoints; proxy keeps API calls on the same origin.

```
ReactJSMobileApp/
├── src/
│   ├── App.js
│   ├── api.js
│   ├── components/
│   └── hooks/useFetch.js
├── vercel.json
└── webpack.config.js
```

## Securing the Serverless API

- API Gateway fronts five Lambda handlers (GET/POST/PUT/DELETE) with API keys, throttles, and schema validation.  
- Vercel injects headers server-side so secrets stay out of the bundle.

```json
{
  "routes": [
    {
      "src": "/api/(.*)",
      "dest": "https://i0p044nu8c.execute-api.us-east-1.amazonaws.com/prod/$1",
      "headers": {
        "x-api-key": "${API_GATEWAY_KEY}"
      }
    }
  ]
}
```

- Lambda normalises payloads, returns structured errors, and logs request IDs for tracing.

## Client Data Flow

### Fetch characters safely

```javascript
useEffect(() => {
  let isMounted = true;

  const fetchCharacters = async () => {
    try {
      setLoading(true);
      const response = await api.get('/api/characters');
      if (isMounted) setCharacters(response.data);
    } catch (err) {
      if (isMounted) setError('Unable to load characters right now.');
    } finally {
      if (isMounted) setLoading(false);
    }
  };

  fetchCharacters();
  return () => {
    isMounted = false;
  };
}, []);
```

- Guards prevent state updates after unmounts, eliminating React warnings.

### Optimistic updates with rollback

```javascript
const handleUpdate = async (character) => {
  setCharacters((prev) =>
    prev.map((item) => (item.id === character.id ? character : item))
  );
  setShowUpdateModal(false);

  try {
    await api.put(`/api/characters/${character.id}`, character);
  } catch (error) {
    setError('Could not save changes. Reverting.');
    setCharacters((prev) => prevCache);
  }
};
```

- Perceived speed stays high even when Lambda cold starts introduce latency.

### Filter with memoised selectors

```javascript
const filteredCharacters = useMemo(() => {
  if (selectedCategory === 'all') return characters;
  return characters.filter((character) => {
    const category = character.category?.toLowerCase();
    const role = character.role?.toLowerCase();
    return category === selectedCategory || role === selectedCategory;
  });
}, [characters, selectedCategory]);
```

- Controlled inputs + `useMemo` keep the grid responsive for larger datasets.

## Integration with Jikan API

- Fetch trending titles once per session, cache in state, display top twelve with art and ratings.  
- Respect `Retry-After` headers and back off on 429s, logging rate-limit metrics.

## Deployment Notes

- Vercel proxying avoids CORS headaches; headers set server-side.  
- Webpack customisations add path aliases and bundle analysis.  
- Environment management uses `.env.*` files synced via Vercel Secrets and AWS Parameter Store.

## Challenges & Resolutions

- **CORS conflicts:** Solved with Vercel proxy routes and API Gateway CORS headers.  
- **Exposed keys risk:** Server-injected `x-api-key` keeps secrets off the client.  
- **Nested data management:** Controlled forms + JSON schema validation reduced runtime errors.  
- **Cold starts:** Optimistic UI updates and skeleton loaders smoothed perceived performance.

## Future Enhancements

1. Layer in Cognito authentication so users own personalised lists.  
2. Add S3-backed image uploads instead of relying on external URLs.  
3. Explore DynamoDB Streams + offline caching for faster refreshes.  
4. Replace Axios with Fetch + Suspense to simplify data flow.  
5. Publish Terraform modules that reproduce the environment quickly.

## Key Takeaways

- **Serverless pairs well with React when edge security and error handling are deliberate.**  
- **Optimistic UI design cushions latency and keeps users engaged.**  
- **Operational maturity (proxies, env management, observability) matters as much as component code.**

## References

- AWS, “Protecting REST APIs with API Keys,” https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-api-key.html.  
- AWS, “Using AWS Lambda with Amazon API Gateway,” https://docs.aws.amazon.com/lambda/latest/dg/services-apigateway.html.  
- Jikan Documentation, “Rate Limiting,” https://docs.api.jikan.moe/#section/Information/Rate-Limiting.
