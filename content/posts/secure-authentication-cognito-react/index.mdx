---
title: "Secure Authentication with JWT, Cognito, and React"
date: "2025-09-15"
slug: "/secure-authentication-cognito-react"
tags: ["Authentication", "AWS", "React", "Security"]
description: "Implementing a secure login flow using Amazon Cognito, JSON Web Tokens, and a React front end, including best practices for token storage and verification."
theme: "Cloud & DevOps"
---

> **Context:** Lab project proving I can wire Cognito + React together; no paying users and no production traffic.  
> **AI assist:** ChatGPT/Copilot helped scaffold the flows; I documented every prompt + manual change in the repo.  
> **Status:** Architecture works in my sandbox accounts—still on the lookout for professional mentorship before owning auth in prod.

## TL;DR

- **Cognito + React delivers secure auth without DIY password storage.** Cognito handles sign-up, MFA, and policies while React manages the user experience.[^cognito]
- **JWTs stay protected.** Access tokens live in memory, refresh tokens ride in HttpOnly cookies, and Lambda verifies signatures against Cognito JWKS.[^jwks]
- **Serverless pieces stay least-privilege.** API Gateway and Lambda enforce scopes, DynamoDB stores data by Cognito user ID, and IAM roles stay tight.[^aws-jwt-verify]
- **DX stays smooth.** Local SAM testing, Playwright UI automation, and GitHub Actions deploys keep the loop fast.

## Project Goals

- Turn prior JWT theory into a production-ready authentication flow.
- Keep secrets out of localStorage while still supporting silent session refresh.
- Enforce token validation server-side with clear separation of concerns.
- Bake in testing and CI/CD so the auth flow stays trustworthy over time.

## Architecture Overview

| Layer | Technology | Responsibility |
| --- | --- | --- |
| Auth Provider | Amazon Cognito User Pools | Hosts hosted UI, handles sign-up, MFA, password policies.[^cognito] |
| Front end | React + TypeScript | Initiates login, stores tokens, refreshes sessions. |
| API | AWS Lambda + API Gateway | Verifies Cognito JWTs, enforces authorisation, returns data. |
| Storage | DynamoDB | Holds application data, keyed by Cognito user ID. |

## Implementation Highlights

### Login flow

1. React app redirects to Cognito Hosted UI (`/oauth2/authorize`).  
2. After successful login, Cognito redirects back with an authorization code.  
3. React exchanges the code for tokens (ID, access, refresh) via the Cognito token endpoint.  
4. Tokens are stored in memory (or HttpOnly cookies) and attached to API requests as `Authorization: Bearer <access_token>`.  
5. Lambda functions validate the token signature using Cognito’s JSON Web Key Set (JWKS).[^jwks]

### React implementation keeps tokens out of localStorage

```ts
import { useEffect } from "react";
import { exchangeCodeForTokens, fetchWithAuth } from "./auth";

export function useAuth() {
  const [session, setSession] = useState<Session | null>(null);

  useEffect(() => {
    const url = new URL(window.location.href);
    const code = url.searchParams.get("code");
    if (!code) return;

    exchangeCodeForTokens(code).then(tokens => {
      setSession(tokens);
      window.history.replaceState({}, "", url.pathname);
    });
  }, []);

  async function authenticatedFetch(input: RequestInfo, init?: RequestInit) {
    if (!session) throw new Error("Not authenticated");
    return fetchWithAuth(session.accessToken, input, init);
  }

  return { session, authenticatedFetch };
}
```

Tokens are kept in memory using React context. If a page refresh is required, I store the refresh token in an HttpOnly cookie and use a silent refresh endpoint (`/auth/refresh`) that returns new access tokens without exposing credentials to JavaScript.

### Lambda verification relies on managed JWKS

```ts
import { CognitoJwtVerifier } from "aws-jwt-verify";

const verifier = CognitoJwtVerifier.create({
  userPoolId: process.env.USER_POOL_ID!,
  tokenUse: "access",
  clientId: process.env.CLIENT_ID!,
});

export const handler = async (event) => {
  try {
    const token = event.headers.authorization?.split(" ")[1];
    const payload = await verifier.verify(token);
    // payload.sub is the user ID
    return { statusCode: 200, body: JSON.stringify({ message: "ok" }) };
  } catch (err) {
    return { statusCode: 401, body: JSON.stringify({ error: "Unauthorized" }) };
  }
};
```

The verifier caches JWKS keys and validates signatures, expiration, and client ID automatically.[^aws-jwt-verify]

## Results

- **Password handling offloaded.** Cognito manages credentials, MFA, and hosted UI while the app focuses on UX.
- **Session refreshes stay secure.** HttpOnly cookies plus memory storage prevent accidental token leakage via XSS.
- **Serverless APIs trust but verify.** Lambda rejects invalid tokens before business logic runs, keeping DynamoDB writes clean.

## Security Best Practices

- **Never store secrets in localStorage.** Stick to memory or HttpOnly cookies to mitigate XSS.  
- **Short-lived access tokens.** Cognito defaults to one-hour access tokens; combine with refresh tokens for seamless reauthentication.  
- **Scoped API routes.** API Gateway authorisers and Lambda checks ensure only valid tokens reach business logic.  
- **Least privilege IAM roles.** Lambda functions assume roles limited to required DynamoDB tables.  
- **Audit logging.** CloudWatch logs record token validation errors, aiding incident response.

## Developer Experience

- **Local testing.** I run Cognito locally via AWS SAM’s `cognito-idp` integration and seed users with temporary passwords.  
- **Integration tests.** Playwright tests automate login using the hosted UI in a headless browser, verifying redirects and cookie storage.  
- **CI/CD.** GitHub Actions deploys the front end (S3 + CloudFront) and Lambda functions, invalidating caches after success.

## Lessons Learned

- **Managed identity reduces cognitive load.** Cognito’s hosted UI and policies saved weeks of DIY auth hardening.
- **Token storage strategy matters.** Moving refresh tokens into HttpOnly cookies eliminated accidental leaks during testing.
- **Automation keeps trust high.** Playwright and CI/CD caught regressions instantly, especially around redirect URLs and cookie scopes.

## Next Steps

- Add fine-grained API scopes mapped to user groups or roles.
- Integrate AWS WAF + CloudFront logs for proactive anomaly detection.
- Expand the Playwright suite with mobile viewport auth tests.

## Key Takeaways

- **Use Cognito to offload identity but still validate tokens yourself.**
- **Keep access tokens in memory and refresh tokens in HttpOnly cookies to balance UX and security.**
- **Automate login flows in tests so auth regressions surface before production.**

## References

[^cognito]: AWS Documentation, “Amazon Cognito User Pools,” accessed May 2025, https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools.html.  
[^jwks]: AWS Documentation, “Using JSON Web Tokens with Amazon Cognito,” accessed May 2025, https://docs.aws.amazon.com/cognito/latest/developerguide/token-endpoint.html.  
[^aws-jwt-verify]: AWS Labs, “aws-jwt-verify,” accessed May 2025, https://github.com/awslabs/aws-jwt-verify.
