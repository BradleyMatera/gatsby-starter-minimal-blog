---
title: "Cognito Authentication With React: A Small, Verifiable Setup"
date: "2025-05-14"
slug: "/secure-authentication-cognito-react"
tags: ["aws", "authentication", "react"]
description: "A step by step Cognito setup with exact files, commands, and verification checks."
theme: "Cloud"
---

Authentication is not magic. It is config, tokens, and clear checks.

This post shows a minimal Cognito plus React setup you can verify.

You will create a user pool, wire a frontend, and confirm login works.

I cannot verify these steps from this blog repo. Treat this as a lab guide you can run locally.

## The promise

By the end, you will:

- create a Cognito user pool with email sign in
- wire a React app to Cognito with Amplify
- verify login and token storage in the browser

> "If you can log in and read the ID token, your setup is real."

## What this is

**High level:** Cognito is AWS’s hosted identity service. It stores users and issues tokens when they sign in.

**Low level:** You create a user pool, configure an app client, then point your React app at the pool using config values.

**Key terms:**

- **User pool:** The Cognito database of users.
- **App client:** The OAuth client for your frontend.
- **ID token:** A JWT that represents the signed in user.
- **Amplify Auth:** A library that handles the hosted auth flow.

## What you need

- AWS account
- Node 18 or later
- A React app

Tools:

- AWS Console
- npm

## Start to Finish

### Step 1: Create the user pool
Goal:
Create a user pool with email as the sign in method.

Actions:
- AWS Console path: Cognito → User pools → Create user pool
- Set:
  - Sign in options: Email
  - MFA: Optional or Off
  - Email verification: On
- Save the pool.

Why:
The user pool is the identity store. Email sign in keeps the flow simple. MFA can be added later after the basics work. Verification ensures the email is real. This is the minimum to support a demo login.

Verify:
- In the pool, open Users.
- Expected: empty list with an Add user button.
- This confirms the pool exists.

If it fails:
- Symptom: You cannot create the pool.
- Fix: Check AWS region permissions and try again.

### Step 2: Create an app client
Goal:
Create an app client so the frontend can authenticate.

Actions:
- AWS Console path: User pools → App integration → App clients → Create app client
- Set:
  - Public client
  - No client secret
- Save and copy:
  - User Pool ID
  - App Client ID

Why:
The app client is the OAuth entry point. A public client matches a browser app. No secret prevents exposing sensitive credentials. The IDs are required for your frontend config. These values are the connection between AWS and your app.

Verify:
- You can see the App Client ID in the list.
- Expected: a string like `2a1b3c4d5e6f7g8h9i0j`.
- This confirms the client exists.

If it fails:
- Symptom: You cannot save the client.
- Fix: Ensure you did not enable a client secret.

### Step 3: Create the React app
Goal:
Create a minimal React app with Amplify installed.

Actions:
- Commands:
  ```bash
  npm create vite@latest cognito-demo -- --template react
  cd cognito-demo
  npm install aws-amplify
  ```
- File path: `src/main.jsx`
- Keep the default render call.

Why:
Vite gives a clean React starter without extra config. Amplify provides the Auth helpers you need. This keeps the tutorial small and focused. You can swap tooling later once the flow works.

Verify:
- Run:
  ```bash
  npm run dev
  ```
- Expected: the Vite dev server starts and the default page loads.
- This confirms the app runs locally.

If it fails:
- Symptom: `npm run dev` fails.
- Fix: Ensure Node 18 is installed and dependencies are installed.

### Step 4: Configure Amplify
Goal:
Point the app at your Cognito pool.

Actions:
- File path: `src/aws-exports.js`
- Add:
  ```js
  export const awsConfig = {
    Auth: {
      Cognito: {
        userPoolId: "YOUR_USER_POOL_ID",
        userPoolClientId: "YOUR_APP_CLIENT_ID"
      }
    }
  };
  ```
- File path: `src/main.jsx`
- Import and configure:
  ```js
  import { Amplify } from "aws-amplify";
  import { awsConfig } from "./aws-exports";

  Amplify.configure(awsConfig);
  ```

Why:
Amplify needs explicit IDs to contact Cognito. Putting config in one file keeps it simple and reusable. The config must be loaded before any auth calls. This step is the actual connection between AWS and your app.

Verify:
- Run:
  ```bash
  npm run dev
  ```
- Expected: app loads with no console errors about Auth or Amplify.
- This confirms config is parsed correctly.

If it fails:
- Symptom: `Auth` or `Amplify` errors in console.
- Fix: Check the import paths and the config keys.

### Step 5: Add a basic sign in form
Goal:
Create a minimal sign in form that calls Cognito.

Actions:
- File path: `src/App.jsx`
- Replace with:
  ```jsx
  import { useState } from "react";
  import { signIn, signOut, getCurrentUser } from "aws-amplify/auth";

  export default function App() {
    const [email, setEmail] = useState("");
    const [password, setPassword] = useState("");
    const [status, setStatus] = useState("signed out");

    async function handleSignIn(e) {
      e.preventDefault();
      await signIn({ username: email, password });
      const user = await getCurrentUser();
      setStatus(`signed in as ${user.username}`);
    }

    async function handleSignOut() {
      await signOut();
      setStatus("signed out");
    }

    return (
      <div style={{ padding: 24 }}>
        <h1>Cognito login</h1>
        <p>{status}</p>
        <form onSubmit={handleSignIn}>
          <input value={email} onChange={(e) => setEmail(e.target.value)} placeholder="email" />
          <input value={password} onChange={(e) => setPassword(e.target.value)} placeholder="password" type="password" />
          <button type="submit">Sign in</button>
        </form>
        <button onClick={handleSignOut}>Sign out</button>
      </div>
    );
  }
  ```

Why:
You need a real auth call to confirm the pool works. A minimal form keeps the surface area small. Using `getCurrentUser` confirms the session actually exists. This is enough for a demo without adding hosted UI.

Verify:
- Create a test user in Cognito.
- Run:
  ```bash
  npm run dev
  ```
- Sign in and expect: `signed in as <email>`.
- This confirms token issuance and user session.

If it fails:
- Symptom: `UserNotFoundException`.
- Fix: Create the user in Cognito or enable self sign up.

## Verify it worked

- You can sign in and see the status line update.
- Refreshing the page still shows signed in after a new login.
- Signing out resets the status.

## Common mistakes

- **Symptom:** `UserPoolId` errors.  
  **Cause:** Wrong pool ID in config.  
  **Fix:** Copy the ID directly from Cognito.

- **Symptom:** Sign in works once, then fails.  
  **Cause:** User is not confirmed.  
  **Fix:** Confirm the user in Cognito or enable auto confirmation.

- **Symptom:** CORS error.  
  **Cause:** Wrong region or endpoint.  
  **Fix:** Ensure you created the pool in the same region you are using.

## Cheat sheet

- Create a user pool with email sign in.
- Create a public app client with no secret.
- Install Amplify and configure it early.
- Build a minimal sign in form.
- Verify with a real Cognito user.

## Next steps

- Add sign up and password reset flows.
- Add route protection for authenticated pages.
- Store tokens only in memory for demos.

## Related links

- https://docs.aws.amazon.com/cognito/
- https://docs.amplify.aws/javascript/build-a-backend/auth/

## Final CTA

Build the smallest auth flow possible, then expand only after login works.
